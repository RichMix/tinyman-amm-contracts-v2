#pragma version 7
// tealish version git+https://github.com/Hipo/tealish.git@0cec751154b0083c2cb79da43b40aa26b367ecc4


// Tinyman AMM V2

// Notes:
// * Tinyman assumes that the asset id of ALGO is 0. Algorand cannot have another ASA with id 0.
// * Fee should be set to 0 for all inner transactions to ensure it is paid by an outer transaction sender instead of the Pool.



// if Txn.ApplicationID == 0:
  txn ApplicationID
  pushint 0
  ==
  bz l0_end
  // then:
    // create app
    // app_global_put("fee_setter", Txn.Sender)
    pushbytes "fee_setter"
    txn Sender
    app_global_put
    // app_global_put("fee_collector", Txn.Sender)
    pushbytes "fee_collector"
    txn Sender
    app_global_put
    // app_global_put("fee_manager", Txn.Sender)
    pushbytes "fee_manager"
    txn Sender
    app_global_put
    // exit(1)
    pushint 1
    return
  l0_end: // end

// switch Txn.OnCompletion:
txn OnCompletion
pushint 0 // NoOp
==
bnz main
txn OnCompletion
pushint 1 // OptIn
==
bnz bootstrap
txn OnCompletion
pushint 2 // CloseOut
==
bnz fail
txn OnCompletion
pushint 4 // UpdateApplication
==
bnz fail
txn OnCompletion
pushint 5 // DeleteApplication
==
bnz fail
err // unexpected value

// block fail
fail:
  // exit(0)
  pushint 0
  return


// block bootstrap
bootstrap:
  // Prerequisite: Pay Algo to Pool Address from User to cover minimum balance
  
  // Txn: AppCall with Optin from Pool Address to Bootstrap pool & ReKey to Application
  // itxn[0]: Pay Algo from Pool to Application
  // itxn[1]: Create Pool Token Asset from Application
  // itxn[2]: Optin Pool to Asset 1
  // itxn[3]: Optin Pool to Asset 2 (if not Algo)
  // itxn[4]: Optin Pool to Pool Token Asset
  // itxn[5]: Transfer Pool Token total supply to Pool Account
  
  // Should fail if:
  // Pool Address (Sender) != SHA512_256("program" + bytes from template and args)
  // Address already opted in to app
  // Required Algo is not sent to the pool address to cover minimum balance
  
  // assert(Txn.ApplicationArgs[0] == "bootstrap")
  txna ApplicationArgs 0
  pushbytes "bootstrap"
  ==
  assert
  
  // Ensure Txn includes rekey to application address
  // assert(Txn.RekeyTo == Global.CurrentApplicationAddress)
  txn RekeyTo
  global CurrentApplicationAddress
  ==
  assert
  
  // int asset_1_id = Txn.Assets[0] [slot 0]
  txna Assets 0
  store 0 // asset_1_id
  // int asset_2_id = Txn.Assets[1] [slot 1]
  txna Assets 1
  store 1 // asset_2_id
  // assert(asset_1_id > asset_2_id)
  load 0 // asset_1_id
  load 1 // asset_2_id
  >
  assert
  
  // bytes pool_address = Txn.Sender [slot 2]
  txn Sender
  store 2 // pool_address
  // int exists [slot 3]
  // bytes asset_1_unit_name [slot 4]
  // bytes asset_2_unit_name [slot 5]
  // int asset_total [slot 6]
  
  // exists, asset_1_unit_name = asset_params_get(AssetUnitName, asset_1_id)
  load 0 // asset_1_id
  asset_params_get AssetUnitName
  store 3 // exists
  store 4 // asset_1_unit_name
  // assert(exists)
  load 3 // exists
  assert
  // Ensure Asset 1 has total supply >= ASSET_MIN_TOTAL
  // _, asset_total = asset_params_get(AssetTotal, asset_1_id)
  load 0 // asset_1_id
  asset_params_get AssetTotal
  pop // discarding value for _
  store 6 // asset_total
  // assert(asset_total >= ASSET_MIN_TOTAL)
  load 6 // asset_total
  pushint 1000000 // ASSET_MIN_TOTAL
  >=
  assert
  
  // if asset_2_id == 0:
    load 1 // asset_2_id
    pushint 0
    ==
    bz l1_else
    // then:
      // asset_2_unit_name = "ALGO"
      pushbytes "ALGO"
      store 5 // asset_2_unit_name
    b l1_end
    l1_else:
    // else:
      // exists, asset_2_unit_name = asset_params_get(AssetUnitName, asset_2_id)
      load 1 // asset_2_id
      asset_params_get AssetUnitName
      store 3 // exists
      store 5 // asset_2_unit_name
      // assert(exists)
      load 3 // exists
      assert
      // Ensure Asset 2 has total supply >= ASSET_MIN_TOTAL
      // _, asset_total = asset_params_get(AssetTotal, asset_2_id)
      load 1 // asset_2_id
      asset_params_get AssetTotal
      pop // discarding value for _
      store 6 // asset_total
      // assert(asset_total >= ASSET_MIN_TOTAL)
      load 6 // asset_total
      pushint 1000000 // ASSET_MIN_TOTAL
      >=
      assert
    l1_end: // end
  
  // bytes pool_token_asset_name = concat("TinymanPool2.0 ", concat(concat(asset_1_unit_name, "-"), asset_2_unit_name)) [slot 7]
  pushbytes "TinymanPool2.0 "
  load 4 // asset_1_unit_name
  pushbytes "-"
  concat
  load 5 // asset_2_unit_name
  concat
  concat
  store 7 // pool_token_asset_name
  
  // Ensure pool_address == SHA512_256("program" + bytes from template and args)
  // bytes program = replace2(3, POOL_TEMPLATE, itob(Global.CurrentApplicationID)) [slot 8]
  pushbytes "\x06\x80\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x81\x00[5\x004\x001\x18\x12D1\x19\x81\x01\x12D\x81\x01C" // POOL_TEMPLATE
  global CurrentApplicationID
  itob
  replace2 3
  store 8 // program
  // program = replace2(11, program, itob(asset_1_id))
  load 8 // program
  load 0 // asset_1_id
  itob
  replace2 11
  store 8 // program
  // program = replace2(19, program, itob(asset_2_id))
  load 8 // program
  load 1 // asset_2_id
  itob
  replace2 19
  store 8 // program
  // assert(pool_address == sha512_256(concat("Program", program)))
  load 2 // pool_address
  pushbytes "Program"
  load 8 // program
  concat
  sha512_256
  ==
  assert
  
  // Use the metadata hash field of the Pool Token asset to store the asset_1_id & asset_2_id.
  // uint64 (8 bytes) + uint64 (8 bytes) + zeros (16 bytes)
  // bytes metadata_hash = concat(itob(asset_1_id), concat(itob(asset_2_id), bzero(16))) [slot 9]
  load 0 // asset_1_id
  itob
  load 1 // asset_2_id
  itob
  pushint 16
  bzero
  concat
  concat
  store 9 // metadata_hash
  
  // itxn[0]: Pay Algo from Pool to Application to fund minimum balance increase because of asset Creation
  // 
  itxn_begin
  // inner_txn:
  pushint 1 // Pay
  itxn_field TypeEnum
  load 2 // pool_address
  itxn_field Sender
  global CurrentApplicationAddress
  itxn_field Receiver
  pushint 100000
  itxn_field Amount
  pushint 0
  itxn_field Fee
  itxn_submit
  
  // itxn[1]: Create Pool Token Asset from Application Address
  // 
  itxn_begin
  // inner_txn:
  pushint 3 // Acfg
  itxn_field TypeEnum
  global CurrentApplicationAddress
  itxn_field Sender
  pushbytes "TMPOOL2"
  itxn_field ConfigAssetUnitName
  load 7 // pool_token_asset_name
  itxn_field ConfigAssetName
  pushint 18446744073709551615 // POOL_TOKEN_TOTAL_SUPPLY
  itxn_field ConfigAssetTotal
  pushint 6
  itxn_field ConfigAssetDecimals
  pushbytes "https://tinyman.org"
  itxn_field ConfigAssetURL
  load 2 // pool_address
  itxn_field ConfigAssetReserve
  load 9 // metadata_hash
  itxn_field ConfigAssetMetadataHash
  pushint 0
  itxn_field Fee
  itxn_submit
  
  // Get the id of the asset just created
  // int pool_token_asset_id = Itxn.CreatedAssetID [slot 10]
  itxn CreatedAssetID
  store 10 // pool_token_asset_id
  
  // itxn[2]: Optin Pool to Asset 1
  // 
  itxn_begin
  // inner_txn:
  pushint 4 // Axfer
  itxn_field TypeEnum
  load 2 // pool_address
  itxn_field Sender
  load 2 // pool_address
  itxn_field AssetReceiver
  load 0 // asset_1_id
  itxn_field XferAsset
  pushint 0
  itxn_field Amount
  pushint 0
  itxn_field Fee
  itxn_submit
  
  // itxn[3]: Optin Pool to Asset 2
  // if asset_2_id > 0:
    load 1 // asset_2_id
    pushint 0
    >
    bz l2_end
    // then:
      // 
      itxn_begin
      // inner_txn:
      pushint 4 // Axfer
      itxn_field TypeEnum
      load 2 // pool_address
      itxn_field Sender
      load 2 // pool_address
      itxn_field AssetReceiver
      load 1 // asset_2_id
      itxn_field XferAsset
      pushint 0
      itxn_field Amount
      pushint 0
      itxn_field Fee
      itxn_submit
    l2_end: // end
  
  // itxn[4]: Optin Pool to Pool Token Asset
  // 
  itxn_begin
  // inner_txn:
  pushint 4 // Axfer
  itxn_field TypeEnum
  load 2 // pool_address
  itxn_field Sender
  load 2 // pool_address
  itxn_field AssetReceiver
  load 10 // pool_token_asset_id
  itxn_field XferAsset
  pushint 0
  itxn_field Amount
  pushint 0
  itxn_field Fee
  itxn_submit
  
  // itxn[5]: Transfer Pool Token total supply to Pool Account
  // 
  itxn_begin
  // inner_txn:
  pushint 4 // Axfer
  itxn_field TypeEnum
  global CurrentApplicationAddress
  itxn_field Sender
  load 2 // pool_address
  itxn_field AssetReceiver
  load 10 // pool_token_asset_id
  itxn_field XferAsset
  pushint 18446744073709551615 // POOL_TOKEN_TOTAL_SUPPLY
  itxn_field AssetAmount
  pushint 0
  itxn_field Fee
  itxn_submit
  
  // State updates
  // app_local_put(0, "asset_1_id", asset_1_id)
  pushint 0
  pushbytes "asset_1_id"
  load 0 // asset_1_id
  app_local_put
  // app_local_put(0, "asset_2_id", asset_2_id)
  pushint 0
  pushbytes "asset_2_id"
  load 1 // asset_2_id
  app_local_put
  // app_local_put(0, "pool_token_asset_id", pool_token_asset_id)
  pushint 0
  pushbytes "pool_token_asset_id"
  load 10 // pool_token_asset_id
  app_local_put
  
  // Set all remaining keys with initial values
  // app_local_put(0, "total_fee_share", 30)
  pushint 0
  pushbytes "total_fee_share"
  pushint 30
  app_local_put
  // app_local_put(0, "protocol_fee_ratio", 6)
  pushint 0
  pushbytes "protocol_fee_ratio"
  pushint 6
  app_local_put
  // app_local_put(0, "asset_1_reserves", 0)
  pushint 0
  pushbytes "asset_1_reserves"
  pushint 0
  app_local_put
  // app_local_put(0, "asset_2_reserves", 0)
  pushint 0
  pushbytes "asset_2_reserves"
  pushint 0
  app_local_put
  // app_local_put(0, "issued_pool_tokens", 0)
  pushint 0
  pushbytes "issued_pool_tokens"
  pushint 0
  app_local_put
  // app_local_put(0, "asset_1_protocol_fees", 0)
  pushint 0
  pushbytes "asset_1_protocol_fees"
  pushint 0
  app_local_put
  // app_local_put(0, "asset_2_protocol_fees", 0)
  pushint 0
  pushbytes "asset_2_protocol_fees"
  pushint 0
  app_local_put
  // app_local_put(0, "lock", 0)
  pushint 0
  pushbytes "lock"
  pushint 0
  app_local_put
  // app_local_put(0, "asset_1_cumulative_price", BYTE_ZERO)
  pushint 0
  pushbytes "asset_1_cumulative_price"
  pushbytes "\x00\x00\x00\x00\x00\x00\x00\x00" // BYTE_ZERO
  app_local_put
  // app_local_put(0, "asset_2_cumulative_price", BYTE_ZERO)
  pushint 0
  pushbytes "asset_2_cumulative_price"
  pushbytes "\x00\x00\x00\x00\x00\x00\x00\x00" // BYTE_ZERO
  app_local_put
  // app_local_put(0, "cumulative_price_update_timestamp", Global.LatestTimestamp)
  pushint 0
  pushbytes "cumulative_price_update_timestamp"
  global LatestTimestamp
  app_local_put
  // exit(1)
  pushint 1
  return

// block main
main:
  // bytes user_address = Txn.Sender [slot 0]
  txn Sender
  store 0 // user_address
  // switch Txn.ApplicationArgs[0]:
  txna ApplicationArgs 0
  pushbytes "set_fee_collector"
  ==
  bnz main__set_fee_collector
  txna ApplicationArgs 0
  pushbytes "set_fee_setter"
  ==
  bnz main__set_fee_setter
  txna ApplicationArgs 0
  pushbytes "set_fee_manager"
  ==
  bnz main__set_fee_manager
  txna ApplicationArgs 0
  pushbytes "claim_fees"
  ==
  bnz main__claim_fees
  txna ApplicationArgs 0
  pushbytes "claim_extra"
  ==
  bnz main__claim_extra
  txna ApplicationArgs 0
  pushbytes "set_fee"
  ==
  bnz main__set_fee
  b main__amm // else
  
  // block set_fee_collector
  main__set_fee_collector:
    // Set a new fee collector, only fee manager can call this method
    // Txn: AppCall from fee_manager
    
    // assert(user_address == app_global_get("fee_manager"))
    load 0 // user_address
    pushbytes "fee_manager"
    app_global_get
    ==
    assert
    
    // State updates
    // app_global_put("fee_collector", Txn.Accounts[1])
    pushbytes "fee_collector"
    txna Accounts 1
    app_global_put
    // exit(1)
    pushint 1
    return
  
  // block set_fee_setter
  main__set_fee_setter:
    // Set a new fee setter, only fee manager can call this method
    // Txn: AppCall from fee_manager
    
    // assert(user_address == app_global_get("fee_manager"))
    load 0 // user_address
    pushbytes "fee_manager"
    app_global_get
    ==
    assert
    
    // State updates
    // app_global_put("fee_setter", Txn.Accounts[1])
    pushbytes "fee_setter"
    txna Accounts 1
    app_global_put
    // exit(1)
    pushint 1
    return
  
  // block set_fee_manager
  main__set_fee_manager:
    // Set a new fee manager, only fee manager can call this method
    // Txn: AppCall from fee_manager
    
    // assert(user_address == app_global_get("fee_manager"))
    load 0 // user_address
    pushbytes "fee_manager"
    app_global_get
    ==
    assert
    
    // State updates
    // app_global_put("fee_manager", Txn.Accounts[1])
    pushbytes "fee_manager"
    txna Accounts 1
    app_global_put
    // exit(1)
    pushint 1
    return
  
  // block claim_fees
  main__claim_fees:
    // Transfer accumulated fees from the pool to the fee_collector
    // Txn: AppCall from User
    // itxn[0]: Transfer Asset 1 to fee_collector from Pool
    // itxn[1]: Transfer Asset 2 to fee_collector from Pool
    
    // bytes pool_address = Txn.Accounts[1] [slot 1]
    txna Accounts 1
    store 1 // pool_address
    // int asset_1_id = app_local_get(1, "asset_1_id") [slot 2]
    pushint 1
    pushbytes "asset_1_id"
    app_local_get
    store 2 // asset_1_id
    // int asset_2_id = app_local_get(1, "asset_2_id") [slot 3]
    pushint 1
    pushbytes "asset_2_id"
    app_local_get
    store 3 // asset_2_id
    // int asset_1_protocol_fees = app_local_get(1, "asset_1_protocol_fees") [slot 4]
    pushint 1
    pushbytes "asset_1_protocol_fees"
    app_local_get
    store 4 // asset_1_protocol_fees
    // int asset_2_protocol_fees = app_local_get(1, "asset_2_protocol_fees") [slot 5]
    pushint 1
    pushbytes "asset_2_protocol_fees"
    app_local_get
    store 5 // asset_2_protocol_fees
    
    // assert(asset_1_protocol_fees || asset_2_protocol_fees)
    load 4 // asset_1_protocol_fees
    load 5 // asset_2_protocol_fees
    ||
    assert
    // transfer(asset_1_id, asset_1_protocol_fees, pool_address, app_global_get("fee_collector"))
    load 2 // asset_1_id
    load 4 // asset_1_protocol_fees
    load 1 // pool_address
    pushbytes "fee_collector"
    app_global_get
    callsub __func__transfer
    // transfer(asset_2_id, asset_2_protocol_fees, pool_address, app_global_get("fee_collector"))
    load 3 // asset_2_id
    load 5 // asset_2_protocol_fees
    load 1 // pool_address
    pushbytes "fee_collector"
    app_global_get
    callsub __func__transfer
    
    // State updates
    // app_local_put(1, "asset_1_protocol_fees", 0)
    pushint 1
    pushbytes "asset_1_protocol_fees"
    pushint 0
    app_local_put
    // app_local_put(1, "asset_2_protocol_fees", 0)
    pushint 1
    pushbytes "asset_2_protocol_fees"
    pushint 0
    app_local_put
    // exit(1)
    pushint 1
    return
  
  // block claim_extra
  main__claim_extra:
    // Transfer any extra (donations) to the fee_collector
    
    // Txn: AppCall from User
    // itxn[0]: Transfer Asset 1 to fee_collector from Pool
    // itxn[1]: Transfer Asset 2 to fee_collector from Pool
    
    // bytes pool_address = Txn.Accounts[1] [slot 1]
    txna Accounts 1
    store 1 // pool_address
    // int asset_1_id = app_local_get(1, "asset_1_id") [slot 2]
    pushint 1
    pushbytes "asset_1_id"
    app_local_get
    store 2 // asset_1_id
    // int asset_2_id = app_local_get(1, "asset_2_id") [slot 3]
    pushint 1
    pushbytes "asset_2_id"
    app_local_get
    store 3 // asset_2_id
    
    // int asset_1_amount = get_balance(1, asset_1_id) - (app_local_get(1, "asset_1_reserves") + app_local_get(1, "asset_1_protocol_fees")) [slot 4]
    pushint 1
    load 2 // asset_1_id
    callsub __func__get_balance
    pushint 1
    pushbytes "asset_1_reserves"
    app_local_get
    pushint 1
    pushbytes "asset_1_protocol_fees"
    app_local_get
    +
    -
    store 4 // asset_1_amount
    // int asset_2_amount = get_balance(1, asset_2_id) - (app_local_get(1, "asset_2_reserves") + app_local_get(1, "asset_2_protocol_fees")) [slot 5]
    pushint 1
    load 3 // asset_2_id
    callsub __func__get_balance
    pushint 1
    pushbytes "asset_2_reserves"
    app_local_get
    pushint 1
    pushbytes "asset_2_protocol_fees"
    app_local_get
    +
    -
    store 5 // asset_2_amount
    
    // assert(asset_1_amount || asset_2_amount)
    load 4 // asset_1_amount
    load 5 // asset_2_amount
    ||
    assert
    // transfer(asset_1_id, asset_1_amount, pool_address, app_global_get("fee_collector"))
    load 2 // asset_1_id
    load 4 // asset_1_amount
    load 1 // pool_address
    pushbytes "fee_collector"
    app_global_get
    callsub __func__transfer
    // transfer(asset_2_id, asset_2_amount, pool_address, app_global_get("fee_collector"))
    load 3 // asset_2_id
    load 5 // asset_2_amount
    load 1 // pool_address
    pushbytes "fee_collector"
    app_global_get
    callsub __func__transfer
    // exit(1)
    pushint 1
    return
  
  // block set_fee
  main__set_fee:
    // Set a new fee collector, only fee setter can call this method
    // Txn: AppCall from fee_setter
    // assert(user_address == app_global_get("fee_setter"))
    load 0 // user_address
    pushbytes "fee_setter"
    app_global_get
    ==
    assert
    
    // int total_fee_share = btoi(Txn.ApplicationArgs[1]) [slot 1]
    txna ApplicationArgs 1
    btoi
    store 1 // total_fee_share
    // int protocol_fee_ratio = btoi(Txn.ApplicationArgs[2]) [slot 2]
    txna ApplicationArgs 2
    btoi
    store 2 // protocol_fee_ratio
    
    // assert(total_fee_share <= 100)
    load 1 // total_fee_share
    pushint 100
    <=
    assert
    // assert(total_fee_share >= 1)
    load 1 // total_fee_share
    pushint 1
    >=
    assert
    // assert(protocol_fee_ratio <= 10)
    load 2 // protocol_fee_ratio
    pushint 10
    <=
    assert
    // assert(protocol_fee_ratio >= 3)
    load 2 // protocol_fee_ratio
    pushint 3
    >=
    assert
    
    // State updates
    // app_local_put(1, "total_fee_share", total_fee_share)
    pushint 1
    pushbytes "total_fee_share"
    load 1 // total_fee_share
    app_local_put
    // app_local_put(1, "protocol_fee_ratio", protocol_fee_ratio)
    pushint 1
    pushbytes "protocol_fee_ratio"
    load 2 // protocol_fee_ratio
    app_local_put
    // exit(1)
    pushint 1
    return
  
  // block amm
  main__amm:
    // bytes pool_address = Txn.Accounts[1] [slot 1]
    txna Accounts 1
    store 1 // pool_address
    // int asset_1_id = app_local_get(1, "asset_1_id") [slot 2]
    pushint 1
    pushbytes "asset_1_id"
    app_local_get
    store 2 // asset_1_id
    // int asset_2_id = app_local_get(1, "asset_2_id") [slot 3]
    pushint 1
    pushbytes "asset_2_id"
    app_local_get
    store 3 // asset_2_id
    // int pool_token_asset_id = app_local_get(1, "pool_token_asset_id") [slot 4]
    pushint 1
    pushbytes "pool_token_asset_id"
    app_local_get
    store 4 // pool_token_asset_id
    // int asset_1_reserves = app_local_get(1, "asset_1_reserves") [slot 5]
    pushint 1
    pushbytes "asset_1_reserves"
    app_local_get
    store 5 // asset_1_reserves
    // int asset_2_reserves = app_local_get(1, "asset_2_reserves") [slot 6]
    pushint 1
    pushbytes "asset_2_reserves"
    app_local_get
    store 6 // asset_2_reserves
    // int issued_pool_tokens = app_local_get(1, "issued_pool_tokens") [slot 7]
    pushint 1
    pushbytes "issued_pool_tokens"
    app_local_get
    store 7 // issued_pool_tokens
    // int asset_1_protocol_fees = app_local_get(1, "asset_1_protocol_fees") [slot 8]
    pushint 1
    pushbytes "asset_1_protocol_fees"
    app_local_get
    store 8 // asset_1_protocol_fees
    // int asset_2_protocol_fees = app_local_get(1, "asset_2_protocol_fees") [slot 9]
    pushint 1
    pushbytes "asset_2_protocol_fees"
    app_local_get
    store 9 // asset_2_protocol_fees
    
    // assert((Txn.ApplicationArgs[0] == "verify_flash_swap") || (app_local_get(1, "lock") == 0))
    txna ApplicationArgs 0
    pushbytes "verify_flash_swap"
    ==
    pushint 1
    pushbytes "lock"
    app_local_get
    pushint 0
    ==
    ||
    assert
    
    // switch Txn.ApplicationArgs[0]:
    txna ApplicationArgs 0
    pushbytes "add_initial_liquidity"
    ==
    bnz main__amm__add_initial_liquidity
    txna ApplicationArgs 0
    pushbytes "add_liquidity"
    ==
    bnz main__amm__add_liquidity
    txna ApplicationArgs 0
    pushbytes "remove_liquidity"
    ==
    bnz main__amm__remove_liquidity
    txna ApplicationArgs 0
    pushbytes "swap"
    ==
    bnz main__amm__swap
    txna ApplicationArgs 0
    pushbytes "flash_loan"
    ==
    bnz main__amm__flash_loan
    txna ApplicationArgs 0
    pushbytes "verify_flash_loan"
    ==
    bnz main__amm__verify_flash_loan
    txna ApplicationArgs 0
    pushbytes "flash_swap"
    ==
    bnz main__amm__flash_swap
    txna ApplicationArgs 0
    pushbytes "verify_flash_swap"
    ==
    bnz main__amm__verify_flash_swap
    err // unexpected value
    
    // block swap
    main__amm__swap:
      // update_price_oracle()
      callsub main__amm__func__update_price_oracle
      // Gtxn[N-1]: Transfer Input Asset to Pool from User
      // Gtxn[N]: AppCall from User
      // itxn[0]: Transfer Output Asset to User from Pool
      
      // int input_txn_index = Txn.GroupIndex - 1 [slot 10]
      txn GroupIndex
      pushint 1
      -
      store 10 // input_txn_index
      // bytes mode = Txn.ApplicationArgs[1] [slot 11]
      txna ApplicationArgs 1
      store 11 // mode
      // int min_output = btoi(Txn.ApplicationArgs[2]) [slot 12]
      txna ApplicationArgs 2
      btoi
      store 12 // min_output
      // int input_asset_id [slot 13]
      // int output_asset_id [slot 14]
      // int input_amount [slot 15]
      
      // if Gtxn[input_txn_index].TypeEnum == Pay:
        load 10 // input_txn_index
        gtxns TypeEnum
        pushint 1 // Pay
        ==
        bz l3_elif_0
        // then:
          // assert(Gtxn[input_txn_index].Receiver == pool_address)
          load 10 // input_txn_index
          gtxns Receiver
          load 1 // pool_address
          ==
          assert
          // input_asset_id = 0
          pushint 0
          store 13 // input_asset_id
          // input_amount = Gtxn[input_txn_index].Amount
          load 10 // input_txn_index
          gtxns Amount
          store 15 // input_amount
        b l3_end
        l3_elif_0:
        // elif Gtxn[input_txn_index].TypeEnum == Axfer:
        load 10 // input_txn_index
        gtxns TypeEnum
        pushint 4 // Axfer
        ==
        bz l3_else
          // assert(Gtxn[input_txn_index].AssetReceiver == pool_address)
          load 10 // input_txn_index
          gtxns AssetReceiver
          load 1 // pool_address
          ==
          assert
          // input_asset_id = Gtxn[input_txn_index].XferAsset
          load 10 // input_txn_index
          gtxns XferAsset
          store 13 // input_asset_id
          // input_amount = Gtxn[input_txn_index].AssetAmount
          load 10 // input_txn_index
          gtxns AssetAmount
          store 15 // input_amount
        b l3_end
        l3_else:
        // else:
          // error()
          err
        l3_end: // end
      // assert(Gtxn[input_txn_index].Sender == user_address)
      load 10 // input_txn_index
      gtxns Sender
      load 0 // user_address
      ==
      assert
      
      // int input_supply [slot 16]
      // int output_supply [slot 17]
      // if input_asset_id == asset_1_id:
        load 13 // input_asset_id
        load 2 // asset_1_id
        ==
        bz l4_elif_0
        // then:
          // output_asset_id = asset_2_id
          load 3 // asset_2_id
          store 14 // output_asset_id
          // input_supply = asset_1_reserves
          load 5 // asset_1_reserves
          store 16 // input_supply
          // output_supply = asset_2_reserves
          load 6 // asset_2_reserves
          store 17 // output_supply
        b l4_end
        l4_elif_0:
        // elif input_asset_id == asset_2_id:
        load 13 // input_asset_id
        load 3 // asset_2_id
        ==
        bz l4_else
          // output_asset_id = asset_1_id
          load 2 // asset_1_id
          store 14 // output_asset_id
          // input_supply = asset_2_reserves
          load 6 // asset_2_reserves
          store 16 // input_supply
          // output_supply = asset_1_reserves
          load 5 // asset_1_reserves
          store 17 // output_supply
        b l4_end
        l4_else:
        // else:
          // error()
          err
        l4_end: // end
      
      // int total_fee_amount [slot 18]
      // int poolers_fee_amount [slot 19]
      // int protocol_fee_amount [slot 20]
      // int swap_amount [slot 21]
      // int output_amount [slot 22]
      // int change = 0 [slot 23]
      pushint 0
      store 23 // change
      // if mode == 'fixed-input':
        load 11 // mode
        pushbytes "fixed-input"
        ==
        bz l5_elif_0
        // then:
          // total_fee_amount, poolers_fee_amount, protocol_fee_amount = calculate_fixed_input_fee_amounts(input_amount)
          load 15 // input_amount
          callsub __func__calculate_fixed_input_fee_amounts
          store 18 // total_fee_amount
          store 19 // poolers_fee_amount
          store 20 // protocol_fee_amount
          // swap_amount = input_amount - total_fee_amount
          load 15 // input_amount
          load 18 // total_fee_amount
          -
          store 21 // swap_amount
          // output_amount = calculate_fixed_input_swap(input_supply, output_supply, swap_amount)
          load 16 // input_supply
          load 17 // output_supply
          load 21 // swap_amount
          callsub __func__calculate_fixed_input_swap
          store 22 // output_amount
          
          // assert(total_fee_amount)
          load 18 // total_fee_amount
          assert
          // assert(output_amount >= min_output)
          load 22 // output_amount
          load 12 // min_output
          >=
          assert
        b l5_end
        l5_elif_0:
        // elif mode == 'fixed-output':
        load 11 // mode
        pushbytes "fixed-output"
        ==
        bz l5_else
          // output_amount = min_output
          load 12 // min_output
          store 22 // output_amount
          // swap_amount = calculate_fixed_output_swap(input_supply, output_supply, output_amount)
          load 16 // input_supply
          load 17 // output_supply
          load 22 // output_amount
          callsub __func__calculate_fixed_output_swap
          store 21 // swap_amount
          // total_fee_amount, poolers_fee_amount, protocol_fee_amount = calculate_fixed_output_fee_amounts(swap_amount)
          load 21 // swap_amount
          callsub __func__calculate_fixed_output_fee_amounts
          store 18 // total_fee_amount
          store 19 // poolers_fee_amount
          store 20 // protocol_fee_amount
          // int required_input_amount = swap_amount + total_fee_amount [slot 24]
          load 21 // swap_amount
          load 18 // total_fee_amount
          +
          store 24 // required_input_amount
          
          // assert(total_fee_amount)
          load 18 // total_fee_amount
          assert
          // assert(input_amount >= required_input_amount)
          load 15 // input_amount
          load 24 // required_input_amount
          >=
          assert
          
          // change = input_amount - required_input_amount
          load 15 // input_amount
          load 24 // required_input_amount
          -
          store 23 // change
          // if change:
            load 23 // change
            bz l6_end
            // then:
              // transfer_to_user(input_asset_id, change)
              load 13 // input_asset_id
              load 23 // change
              callsub main__amm__func__transfer_to_user
            l6_end: // end
        b l5_end
        l5_else:
        // else:
          // error()
          err
        l5_end: // end
      
      // if input_asset_id == asset_1_id:
        load 13 // input_asset_id
        load 2 // asset_1_id
        ==
        bz l7_else
        // then:
          // asset_1_protocol_fees = asset_1_protocol_fees + protocol_fee_amount
          load 8 // asset_1_protocol_fees
          load 20 // protocol_fee_amount
          +
          store 8 // asset_1_protocol_fees
          // asset_1_reserves = asset_1_reserves + (swap_amount + poolers_fee_amount)
          load 5 // asset_1_reserves
          load 21 // swap_amount
          load 19 // poolers_fee_amount
          +
          +
          store 5 // asset_1_reserves
          // asset_2_reserves = asset_2_reserves - output_amount
          load 6 // asset_2_reserves
          load 22 // output_amount
          -
          store 6 // asset_2_reserves
          
          // check_invariant(poolers_fee_amount, 0)
          load 19 // poolers_fee_amount
          pushint 0
          callsub main__amm__func__check_invariant
        b l7_end
        l7_else:
        // else:
          // asset_2_protocol_fees = asset_2_protocol_fees + protocol_fee_amount
          load 9 // asset_2_protocol_fees
          load 20 // protocol_fee_amount
          +
          store 9 // asset_2_protocol_fees
          // asset_2_reserves = asset_2_reserves + (swap_amount + poolers_fee_amount)
          load 6 // asset_2_reserves
          load 21 // swap_amount
          load 19 // poolers_fee_amount
          +
          +
          store 6 // asset_2_reserves
          // asset_1_reserves = asset_1_reserves - output_amount
          load 5 // asset_1_reserves
          load 22 // output_amount
          -
          store 5 // asset_1_reserves
          
          // check_invariant(0, poolers_fee_amount)
          pushint 0
          load 19 // poolers_fee_amount
          callsub main__amm__func__check_invariant
        l7_end: // end
      
      // transfer_to_user(output_asset_id, output_amount)
      load 14 // output_asset_id
      load 22 // output_amount
      callsub main__amm__func__transfer_to_user
      
      // Logs
      // log(concat("input_asset_id %i", itob(input_asset_id)))
      pushbytes "input_asset_id %i"
      load 13 // input_asset_id
      itob
      concat
      log
      // log(concat("input_amount %i", itob(input_amount)))
      pushbytes "input_amount %i"
      load 15 // input_amount
      itob
      concat
      log
      // log(concat("swap_amount %i", itob(swap_amount)))
      pushbytes "swap_amount %i"
      load 21 // swap_amount
      itob
      concat
      log
      // log(concat("change %i", itob(change)))
      pushbytes "change %i"
      load 23 // change
      itob
      concat
      log
      
      // log(concat("output_asset_id %i", itob(output_asset_id)))
      pushbytes "output_asset_id %i"
      load 14 // output_asset_id
      itob
      concat
      log
      // log(concat("output_amount %i", itob(output_amount)))
      pushbytes "output_amount %i"
      load 22 // output_amount
      itob
      concat
      log
      
      // log(concat("poolers_fee_amount %i", itob(poolers_fee_amount)))
      pushbytes "poolers_fee_amount %i"
      load 19 // poolers_fee_amount
      itob
      concat
      log
      // log(concat("protocol_fee_amount %i", itob(protocol_fee_amount)))
      pushbytes "protocol_fee_amount %i"
      load 20 // protocol_fee_amount
      itob
      concat
      log
      // log(concat("total_fee_amount %i", itob(total_fee_amount)))
      pushbytes "total_fee_amount %i"
      load 18 // total_fee_amount
      itob
      concat
      log
      
      // State updates
      // app_local_put(1, "asset_1_reserves", asset_1_reserves)
      pushint 1
      pushbytes "asset_1_reserves"
      load 5 // asset_1_reserves
      app_local_put
      // app_local_put(1, "asset_2_reserves", asset_2_reserves)
      pushint 1
      pushbytes "asset_2_reserves"
      load 6 // asset_2_reserves
      app_local_put
      // app_local_put(1, "asset_1_protocol_fees", asset_1_protocol_fees)
      pushint 1
      pushbytes "asset_1_protocol_fees"
      load 8 // asset_1_protocol_fees
      app_local_put
      // app_local_put(1, "asset_2_protocol_fees", asset_2_protocol_fees)
      pushint 1
      pushbytes "asset_2_protocol_fees"
      load 9 // asset_2_protocol_fees
      app_local_put
      // exit(1)
      pushint 1
      return
    
    // block flash_loan
    main__amm__flash_loan:
      // update_price_oracle()
      callsub main__amm__func__update_price_oracle
      // Gtxn[N]: Flash Loan AppCall from User
      // itxn: Transfer Asset 1 to User from Pool if Asset 1 is requested
      // itxn: Transfer Asset 2 to User from Pool if Asset 2 is requested
      
      // Gtxn[N+X]: Verify Flash Loan AppCall from User
      
      // int index_diff = btoi(Txn.ApplicationArgs[1]) [slot 10]
      txna ApplicationArgs 1
      btoi
      store 10 // index_diff
      // int verify_flash_loan_txn_index = Txn.GroupIndex + index_diff [slot 11]
      txn GroupIndex
      load 10 // index_diff
      +
      store 11 // verify_flash_loan_txn_index
      // assert(Gtxn[verify_flash_loan_txn_index].TypeEnum == Appl)
      load 11 // verify_flash_loan_txn_index
      gtxns TypeEnum
      pushint 6 // Appl
      ==
      assert
      // assert(Gtxn[verify_flash_loan_txn_index].OnCompletion == NoOp)
      load 11 // verify_flash_loan_txn_index
      gtxns OnCompletion
      pushint 0 // NoOp
      ==
      assert
      // assert(Gtxn[verify_flash_loan_txn_index].ApplicationID == Global.CurrentApplicationID)
      load 11 // verify_flash_loan_txn_index
      gtxns ApplicationID
      global CurrentApplicationID
      ==
      assert
      // assert(Gtxn[verify_flash_loan_txn_index].ApplicationArgs[0] == "verify_flash_loan")
      load 11 // verify_flash_loan_txn_index
      gtxnsa ApplicationArgs 0
      pushbytes "verify_flash_loan"
      ==
      assert
      // assert(Gtxn[verify_flash_loan_txn_index].ApplicationArgs[1] == Txn.ApplicationArgs[1])
      load 11 // verify_flash_loan_txn_index
      gtxnsa ApplicationArgs 1
      txna ApplicationArgs 1
      ==
      assert
      // assert(Gtxn[verify_flash_loan_txn_index].Sender == user_address)
      load 11 // verify_flash_loan_txn_index
      gtxns Sender
      load 0 // user_address
      ==
      assert
      // int asset_1_amount = btoi(Txn.ApplicationArgs[2]) [slot 12]
      txna ApplicationArgs 2
      btoi
      store 12 // asset_1_amount
      // int asset_2_amount = btoi(Txn.ApplicationArgs[3]) [slot 13]
      txna ApplicationArgs 3
      btoi
      store 13 // asset_2_amount
      // assert(asset_1_amount || asset_2_amount)
      load 12 // asset_1_amount
      load 13 // asset_2_amount
      ||
      assert
      
      // if asset_1_amount:
        load 12 // asset_1_amount
        bz l8_end
        // then:
          // assert(asset_1_amount <= asset_1_reserves)
          load 12 // asset_1_amount
          load 5 // asset_1_reserves
          <=
          assert
          // transfer_to_user(asset_1_id, asset_1_amount)
          load 2 // asset_1_id
          load 12 // asset_1_amount
          callsub main__amm__func__transfer_to_user
        l8_end: // end
      // if asset_2_amount:
        load 13 // asset_2_amount
        bz l9_end
        // then:
          // assert(asset_2_amount <= asset_2_reserves)
          load 13 // asset_2_amount
          load 6 // asset_2_reserves
          <=
          assert
          // transfer_to_user(asset_2_id, asset_2_amount)
          load 3 // asset_2_id
          load 13 // asset_2_amount
          callsub main__amm__func__transfer_to_user
        l9_end: // end
      // exit(1)
      pushint 1
      return
    
    // block verify_flash_loan
    main__amm__verify_flash_loan:
      // Gtxn[N-X]: Flash Loan AppCall from User
      
      // if borrowed in two assets:
      // Gtxn[N-2]: Transfer Asset 1 to Pool
      // Gtxn[N-1]: Transfer Asset 2 to Pool
      // if borrowed single asset:
      // Gtxn[N-1]: Transfer borrowed Asset to Pool
      // Gtxn[N]: Verify Flash Loan AppCall from User
      
      // int index_diff = btoi(Txn.ApplicationArgs[1]) [slot 10]
      txna ApplicationArgs 1
      btoi
      store 10 // index_diff
      // int flash_loan_txn_index = Txn.GroupIndex - index_diff [slot 11]
      txn GroupIndex
      load 10 // index_diff
      -
      store 11 // flash_loan_txn_index
      // assert(Gtxn[flash_loan_txn_index].TypeEnum == Appl)
      load 11 // flash_loan_txn_index
      gtxns TypeEnum
      pushint 6 // Appl
      ==
      assert
      // assert(Gtxn[flash_loan_txn_index].OnCompletion == NoOp)
      load 11 // flash_loan_txn_index
      gtxns OnCompletion
      pushint 0 // NoOp
      ==
      assert
      // assert(Gtxn[flash_loan_txn_index].ApplicationID == Global.CurrentApplicationID)
      load 11 // flash_loan_txn_index
      gtxns ApplicationID
      global CurrentApplicationID
      ==
      assert
      // assert(Gtxn[flash_loan_txn_index].ApplicationArgs[0] == "flash_loan")
      load 11 // flash_loan_txn_index
      gtxnsa ApplicationArgs 0
      pushbytes "flash_loan"
      ==
      assert
      // assert(Gtxn[flash_loan_txn_index].ApplicationArgs[1] == Txn.ApplicationArgs[1])
      load 11 // flash_loan_txn_index
      gtxnsa ApplicationArgs 1
      txna ApplicationArgs 1
      ==
      assert
      // assert(Gtxn[flash_loan_txn_index].Sender == user_address)
      load 11 // flash_loan_txn_index
      gtxns Sender
      load 0 // user_address
      ==
      assert
      // int asset_1_output_amount = btoi(Gtxn[flash_loan_txn_index].ApplicationArgs[2]) [slot 12]
      load 11 // flash_loan_txn_index
      gtxnsa ApplicationArgs 2
      btoi
      store 12 // asset_1_output_amount
      // int asset_2_output_amount = btoi(Gtxn[flash_loan_txn_index].ApplicationArgs[3]) [slot 13]
      load 11 // flash_loan_txn_index
      gtxnsa ApplicationArgs 3
      btoi
      store 13 // asset_2_output_amount
      
      // if asset_1_output_amount:
        load 12 // asset_1_output_amount
        bz l10_end
        // then:
          // int asset_1_total_fee_amount [slot 14]
          // int asset_1_poolers_fee_amount [slot 15]
          // int asset_1_protocol_fee_amount [slot 16]
          // int asset_1_repayment_amount [slot 17]
          
          // asset_1_total_fee_amount, asset_1_poolers_fee_amount, asset_1_protocol_fee_amount = calculate_fixed_input_fee_amounts(asset_1_output_amount)
          load 12 // asset_1_output_amount
          callsub __func__calculate_fixed_input_fee_amounts
          store 14 // asset_1_total_fee_amount
          store 15 // asset_1_poolers_fee_amount
          store 16 // asset_1_protocol_fee_amount
          // assert(asset_1_total_fee_amount)
          load 14 // asset_1_total_fee_amount
          assert
          // asset_1_repayment_amount = asset_1_output_amount + asset_1_total_fee_amount
          load 12 // asset_1_output_amount
          load 14 // asset_1_total_fee_amount
          +
          store 17 // asset_1_repayment_amount
          
          // int asset_1_txn_index [slot 18]
          // if asset_2_output_amount:
            load 13 // asset_2_output_amount
            bz l11_else
            // then:
              // asset_1_txn_index = Txn.GroupIndex - 2
              txn GroupIndex
              pushint 2
              -
              store 18 // asset_1_txn_index
            b l11_end
            l11_else:
            // else:
              // asset_1_txn_index = Txn.GroupIndex - 1
              txn GroupIndex
              pushint 1
              -
              store 18 // asset_1_txn_index
            l11_end: // end
          
          // assert(Gtxn[asset_1_txn_index].TypeEnum == Axfer)
          load 18 // asset_1_txn_index
          gtxns TypeEnum
          pushint 4 // Axfer
          ==
          assert
          // assert(Gtxn[asset_1_txn_index].XferAsset == asset_1_id)
          load 18 // asset_1_txn_index
          gtxns XferAsset
          load 2 // asset_1_id
          ==
          assert
          // assert(Gtxn[asset_1_txn_index].AssetReceiver == pool_address)
          load 18 // asset_1_txn_index
          gtxns AssetReceiver
          load 1 // pool_address
          ==
          assert
          // assert(Gtxn[asset_1_txn_index].AssetAmount >= asset_1_repayment_amount)
          load 18 // asset_1_txn_index
          gtxns AssetAmount
          load 17 // asset_1_repayment_amount
          >=
          assert
          // assert(Gtxn[asset_1_txn_index].Sender == user_address)
          load 18 // asset_1_txn_index
          gtxns Sender
          load 0 // user_address
          ==
          assert
          // int asset_1_input_amount = Gtxn[asset_1_txn_index].AssetAmount [slot 19]
          load 18 // asset_1_txn_index
          gtxns AssetAmount
          store 19 // asset_1_input_amount
          // int asset_1_donation_amount = asset_1_input_amount - asset_1_repayment_amount [slot 20]
          load 19 // asset_1_input_amount
          load 17 // asset_1_repayment_amount
          -
          store 20 // asset_1_donation_amount
          
          // asset_1_protocol_fees = asset_1_protocol_fees + asset_1_protocol_fee_amount
          load 8 // asset_1_protocol_fees
          load 16 // asset_1_protocol_fee_amount
          +
          store 8 // asset_1_protocol_fees
          // asset_1_reserves = asset_1_reserves + asset_1_poolers_fee_amount
          load 5 // asset_1_reserves
          load 15 // asset_1_poolers_fee_amount
          +
          store 5 // asset_1_reserves
          
          // Logs
          // log(concat("asset_1_output_amount %i", itob(asset_1_output_amount)))
          pushbytes "asset_1_output_amount %i"
          load 12 // asset_1_output_amount
          itob
          concat
          log
          // log(concat("asset_1_input_amount %i", itob(asset_1_input_amount)))
          pushbytes "asset_1_input_amount %i"
          load 19 // asset_1_input_amount
          itob
          concat
          log
          // log(concat("asset_1_donation_amount %i", itob(asset_1_donation_amount)))
          pushbytes "asset_1_donation_amount %i"
          load 20 // asset_1_donation_amount
          itob
          concat
          log
          // log(concat("asset_1_poolers_fee_amount %i", itob(asset_1_poolers_fee_amount)))
          pushbytes "asset_1_poolers_fee_amount %i"
          load 15 // asset_1_poolers_fee_amount
          itob
          concat
          log
          // log(concat("asset_1_protocol_fee_amount %i", itob(asset_1_protocol_fee_amount)))
          pushbytes "asset_1_protocol_fee_amount %i"
          load 16 // asset_1_protocol_fee_amount
          itob
          concat
          log
          // log(concat("asset_1_total_fee_amount %i", itob(asset_1_total_fee_amount)))
          pushbytes "asset_1_total_fee_amount %i"
          load 14 // asset_1_total_fee_amount
          itob
          concat
          log
        l10_end: // end
      
      // if asset_2_output_amount:
        load 13 // asset_2_output_amount
        bz l12_end
        // then:
          // int asset_2_total_fee_amount [slot 21]
          // int asset_2_poolers_fee_amount [slot 22]
          // int asset_2_protocol_fee_amount [slot 23]
          // int asset_2_repayment_amount [slot 24]
          
          // asset_2_total_fee_amount, asset_2_poolers_fee_amount, asset_2_protocol_fee_amount = calculate_fixed_input_fee_amounts(asset_2_output_amount)
          load 13 // asset_2_output_amount
          callsub __func__calculate_fixed_input_fee_amounts
          store 21 // asset_2_total_fee_amount
          store 22 // asset_2_poolers_fee_amount
          store 23 // asset_2_protocol_fee_amount
          // assert(asset_2_total_fee_amount)
          load 21 // asset_2_total_fee_amount
          assert
          // asset_2_repayment_amount = asset_2_output_amount + asset_2_total_fee_amount
          load 13 // asset_2_output_amount
          load 21 // asset_2_total_fee_amount
          +
          store 24 // asset_2_repayment_amount
          
          // int asset_2_txn_index = Txn.GroupIndex - 1 [slot 25]
          txn GroupIndex
          pushint 1
          -
          store 25 // asset_2_txn_index
          // int asset_2_input_amount [slot 26]
          // int asset_2_donation_amount [slot 27]
          // if asset_2_id == 0:
            load 3 // asset_2_id
            pushint 0
            ==
            bz l13_else
            // then:
              // assert(Gtxn[asset_2_txn_index].TypeEnum == Pay)
              load 25 // asset_2_txn_index
              gtxns TypeEnum
              pushint 1 // Pay
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].Receiver == pool_address)
              load 25 // asset_2_txn_index
              gtxns Receiver
              load 1 // pool_address
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].Amount >= asset_2_repayment_amount)
              load 25 // asset_2_txn_index
              gtxns Amount
              load 24 // asset_2_repayment_amount
              >=
              assert
              // assert(Gtxn[asset_2_txn_index].Sender == user_address)
              load 25 // asset_2_txn_index
              gtxns Sender
              load 0 // user_address
              ==
              assert
              // asset_2_input_amount = Gtxn[asset_2_txn_index].Amount
              load 25 // asset_2_txn_index
              gtxns Amount
              store 26 // asset_2_input_amount
            b l13_end
            l13_else:
            // else:
              // assert(Gtxn[asset_2_txn_index].TypeEnum == Axfer)
              load 25 // asset_2_txn_index
              gtxns TypeEnum
              pushint 4 // Axfer
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].XferAsset == asset_2_id)
              load 25 // asset_2_txn_index
              gtxns XferAsset
              load 3 // asset_2_id
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].AssetReceiver == pool_address)
              load 25 // asset_2_txn_index
              gtxns AssetReceiver
              load 1 // pool_address
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].AssetAmount >= asset_2_repayment_amount)
              load 25 // asset_2_txn_index
              gtxns AssetAmount
              load 24 // asset_2_repayment_amount
              >=
              assert
              // assert(Gtxn[asset_2_txn_index].Sender == user_address)
              load 25 // asset_2_txn_index
              gtxns Sender
              load 0 // user_address
              ==
              assert
              // asset_2_input_amount = Gtxn[asset_2_txn_index].AssetAmount
              load 25 // asset_2_txn_index
              gtxns AssetAmount
              store 26 // asset_2_input_amount
            l13_end: // end
          
          // asset_2_donation_amount = asset_2_input_amount - asset_2_repayment_amount
          load 26 // asset_2_input_amount
          load 24 // asset_2_repayment_amount
          -
          store 27 // asset_2_donation_amount
          // asset_2_protocol_fees = asset_2_protocol_fees + asset_2_protocol_fee_amount
          load 9 // asset_2_protocol_fees
          load 23 // asset_2_protocol_fee_amount
          +
          store 9 // asset_2_protocol_fees
          // asset_2_reserves = asset_2_reserves + asset_2_poolers_fee_amount
          load 6 // asset_2_reserves
          load 22 // asset_2_poolers_fee_amount
          +
          store 6 // asset_2_reserves
          
          // Logs
          // log(concat("asset_2_output_amount %i", itob(asset_2_output_amount)))
          pushbytes "asset_2_output_amount %i"
          load 13 // asset_2_output_amount
          itob
          concat
          log
          // log(concat("asset_2_input_amount %i", itob(asset_2_input_amount)))
          pushbytes "asset_2_input_amount %i"
          load 26 // asset_2_input_amount
          itob
          concat
          log
          // log(concat("asset_2_donation_amount %i", itob(asset_2_donation_amount)))
          pushbytes "asset_2_donation_amount %i"
          load 27 // asset_2_donation_amount
          itob
          concat
          log
          // log(concat("asset_2_poolers_fee_amount %i", itob(asset_2_poolers_fee_amount)))
          pushbytes "asset_2_poolers_fee_amount %i"
          load 22 // asset_2_poolers_fee_amount
          itob
          concat
          log
          // log(concat("asset_2_protocol_fee_amount %i", itob(asset_2_protocol_fee_amount)))
          pushbytes "asset_2_protocol_fee_amount %i"
          load 23 // asset_2_protocol_fee_amount
          itob
          concat
          log
          // log(concat("asset_2_total_fee_amount %i", itob(asset_2_total_fee_amount)))
          pushbytes "asset_2_total_fee_amount %i"
          load 21 // asset_2_total_fee_amount
          itob
          concat
          log
        l12_end: // end
      
      // State updates
      // app_local_put(1, "asset_1_reserves", asset_1_reserves)
      pushint 1
      pushbytes "asset_1_reserves"
      load 5 // asset_1_reserves
      app_local_put
      // app_local_put(1, "asset_2_reserves", asset_2_reserves)
      pushint 1
      pushbytes "asset_2_reserves"
      load 6 // asset_2_reserves
      app_local_put
      // app_local_put(1, "asset_1_protocol_fees", asset_1_protocol_fees)
      pushint 1
      pushbytes "asset_1_protocol_fees"
      load 8 // asset_1_protocol_fees
      app_local_put
      // app_local_put(1, "asset_2_protocol_fees", asset_2_protocol_fees)
      pushint 1
      pushbytes "asset_2_protocol_fees"
      load 9 // asset_2_protocol_fees
      app_local_put
      // exit(1)
      pushint 1
      return
    
    // block flash_swap
    main__amm__flash_swap:
      // update_price_oracle()
      callsub main__amm__func__update_price_oracle
      // Gtxn[N]: Flash Swap AppCall from User
      // itxn: Transfer Asset 1 to User from Pool if Asset 1 is requested
      // itxn: Transfer Asset 2 to User from Pool if Asset 2 is requested
      
      // Gtxn[N+X]: Verify Flash Swap AppCall from User
      
      // int index_diff = btoi(Txn.ApplicationArgs[1]) [slot 10]
      txna ApplicationArgs 1
      btoi
      store 10 // index_diff
      // int verify_flash_swap_txn_index = Txn.GroupIndex + index_diff [slot 11]
      txn GroupIndex
      load 10 // index_diff
      +
      store 11 // verify_flash_swap_txn_index
      // assert(Gtxn[verify_flash_swap_txn_index].TypeEnum == Appl)
      load 11 // verify_flash_swap_txn_index
      gtxns TypeEnum
      pushint 6 // Appl
      ==
      assert
      // assert(Gtxn[verify_flash_swap_txn_index].OnCompletion == NoOp)
      load 11 // verify_flash_swap_txn_index
      gtxns OnCompletion
      pushint 0 // NoOp
      ==
      assert
      // assert(Gtxn[verify_flash_swap_txn_index].ApplicationID == Global.CurrentApplicationID)
      load 11 // verify_flash_swap_txn_index
      gtxns ApplicationID
      global CurrentApplicationID
      ==
      assert
      // assert(Gtxn[verify_flash_swap_txn_index].ApplicationArgs[0] == "verify_flash_swap")
      load 11 // verify_flash_swap_txn_index
      gtxnsa ApplicationArgs 0
      pushbytes "verify_flash_swap"
      ==
      assert
      // assert(Gtxn[verify_flash_swap_txn_index].ApplicationArgs[1] == Txn.ApplicationArgs[1])
      load 11 // verify_flash_swap_txn_index
      gtxnsa ApplicationArgs 1
      txna ApplicationArgs 1
      ==
      assert
      // assert(Gtxn[verify_flash_swap_txn_index].Sender == user_address)
      load 11 // verify_flash_swap_txn_index
      gtxns Sender
      load 0 // user_address
      ==
      assert
      // int asset_1_output_amount = btoi(Txn.ApplicationArgs[2]) [slot 12]
      txna ApplicationArgs 2
      btoi
      store 12 // asset_1_output_amount
      // int asset_2_output_amount = btoi(Txn.ApplicationArgs[3]) [slot 13]
      txna ApplicationArgs 3
      btoi
      store 13 // asset_2_output_amount
      // assert(asset_1_output_amount || asset_2_output_amount)
      load 12 // asset_1_output_amount
      load 13 // asset_2_output_amount
      ||
      assert
      
      // if asset_1_output_amount:
        load 12 // asset_1_output_amount
        bz l14_end
        // then:
          // transfer_to_user(asset_1_id, asset_1_output_amount)
          load 2 // asset_1_id
          load 12 // asset_1_output_amount
          callsub main__amm__func__transfer_to_user
        l14_end: // end
      // if asset_2_output_amount:
        load 13 // asset_2_output_amount
        bz l15_end
        // then:
          // transfer_to_user(asset_2_id, asset_2_output_amount)
          load 3 // asset_2_id
          load 13 // asset_2_output_amount
          callsub main__amm__func__transfer_to_user
        l15_end: // end
      
      // Share data between app calls
      // asset_1_balance_after_transfer
      // log(itob(get_balance(1, asset_1_id)))
      pushint 1
      load 2 // asset_1_id
      callsub __func__get_balance
      itob
      log
      // asset_2_balance_after_transfer
      // log(itob(get_balance(1, asset_2_id)))
      pushint 1
      load 3 // asset_2_id
      callsub __func__get_balance
      itob
      log
      
      // app_local_put(1, "lock", 1)
      pushint 1
      pushbytes "lock"
      pushint 1
      app_local_put
      // exit(1)
      pushint 1
      return
    
    // block verify_flash_swap
    main__amm__verify_flash_swap:
      // Gtxn[N-X]: Flash Swap AppCall from User
      // Gtxn[N]: Verify Flash Swap AppCall from User
      
      // int index_diff = btoi(Txn.ApplicationArgs[1]) [slot 10]
      txna ApplicationArgs 1
      btoi
      store 10 // index_diff
      // int flash_swap_txn_index = Txn.GroupIndex - index_diff [slot 11]
      txn GroupIndex
      load 10 // index_diff
      -
      store 11 // flash_swap_txn_index
      // assert(Gtxn[flash_swap_txn_index].TypeEnum == Appl)
      load 11 // flash_swap_txn_index
      gtxns TypeEnum
      pushint 6 // Appl
      ==
      assert
      // assert(Gtxn[flash_swap_txn_index].OnCompletion == NoOp)
      load 11 // flash_swap_txn_index
      gtxns OnCompletion
      pushint 0 // NoOp
      ==
      assert
      // assert(Gtxn[flash_swap_txn_index].ApplicationID == Global.CurrentApplicationID)
      load 11 // flash_swap_txn_index
      gtxns ApplicationID
      global CurrentApplicationID
      ==
      assert
      // assert(Gtxn[flash_swap_txn_index].ApplicationArgs[0] == "flash_swap")
      load 11 // flash_swap_txn_index
      gtxnsa ApplicationArgs 0
      pushbytes "flash_swap"
      ==
      assert
      // assert(Gtxn[flash_swap_txn_index].ApplicationArgs[1] == Txn.ApplicationArgs[1])
      load 11 // flash_swap_txn_index
      gtxnsa ApplicationArgs 1
      txna ApplicationArgs 1
      ==
      assert
      // int asset_1_output_amount = btoi(Gtxn[flash_swap_txn_index].ApplicationArgs[2]) [slot 12]
      load 11 // flash_swap_txn_index
      gtxnsa ApplicationArgs 2
      btoi
      store 12 // asset_1_output_amount
      // int asset_2_output_amount = btoi(Gtxn[flash_swap_txn_index].ApplicationArgs[3]) [slot 13]
      load 11 // flash_swap_txn_index
      gtxnsa ApplicationArgs 3
      btoi
      store 13 // asset_2_output_amount
      
      // int asset_1_balance_after_transfer = btoi(Gtxn[flash_swap_txn_index].Logs[0]) [slot 14]
      load 11 // flash_swap_txn_index
      gtxnsa Logs 0
      btoi
      store 14 // asset_1_balance_after_transfer
      // int asset_2_balance_after_transfer = btoi(Gtxn[flash_swap_txn_index].Logs[1]) [slot 15]
      load 11 // flash_swap_txn_index
      gtxnsa Logs 1
      btoi
      store 15 // asset_2_balance_after_transfer
      // int asset_1_balance = get_balance(1, asset_1_id) [slot 16]
      pushint 1
      load 2 // asset_1_id
      callsub __func__get_balance
      store 16 // asset_1_balance
      // int asset_2_balance = get_balance(1, asset_2_id) [slot 17]
      pushint 1
      load 3 // asset_2_id
      callsub __func__get_balance
      store 17 // asset_2_balance
      
      // int asset_1_input_amount = asset_1_balance - asset_1_balance_after_transfer [slot 18]
      load 16 // asset_1_balance
      load 14 // asset_1_balance_after_transfer
      -
      store 18 // asset_1_input_amount
      // int asset_2_input_amount = asset_2_balance - asset_2_balance_after_transfer [slot 19]
      load 17 // asset_2_balance
      load 15 // asset_2_balance_after_transfer
      -
      store 19 // asset_2_input_amount
      
      // int asset_1_total_fee_amount = 0 [slot 20]
      pushint 0
      store 20 // asset_1_total_fee_amount
      // int asset_1_poolers_fee_amount = 0 [slot 21]
      pushint 0
      store 21 // asset_1_poolers_fee_amount
      // int asset_1_protocol_fee_amount = 0 [slot 22]
      pushint 0
      store 22 // asset_1_protocol_fee_amount
      // if asset_1_input_amount:
        load 18 // asset_1_input_amount
        bz l16_else
        // then:
          // asset_1_total_fee_amount, asset_1_poolers_fee_amount, asset_1_protocol_fee_amount = calculate_fixed_input_fee_amounts(asset_1_input_amount)
          load 18 // asset_1_input_amount
          callsub __func__calculate_fixed_input_fee_amounts
          store 20 // asset_1_total_fee_amount
          store 21 // asset_1_poolers_fee_amount
          store 22 // asset_1_protocol_fee_amount
          // asset_1_protocol_fees = asset_1_protocol_fees + asset_1_protocol_fee_amount
          load 8 // asset_1_protocol_fees
          load 22 // asset_1_protocol_fee_amount
          +
          store 8 // asset_1_protocol_fees
          // asset_1_reserves = (asset_1_reserves - asset_1_output_amount) + (asset_1_input_amount - asset_1_protocol_fee_amount)
          load 5 // asset_1_reserves
          load 12 // asset_1_output_amount
          -
          load 18 // asset_1_input_amount
          load 22 // asset_1_protocol_fee_amount
          -
          +
          store 5 // asset_1_reserves
        b l16_end
        l16_else:
        // else:
          // asset_1_reserves = asset_1_reserves - asset_1_output_amount
          load 5 // asset_1_reserves
          load 12 // asset_1_output_amount
          -
          store 5 // asset_1_reserves
        l16_end: // end
      
      // int asset_2_total_fee_amount = 0 [slot 23]
      pushint 0
      store 23 // asset_2_total_fee_amount
      // int asset_2_poolers_fee_amount = 0 [slot 24]
      pushint 0
      store 24 // asset_2_poolers_fee_amount
      // int asset_2_protocol_fee_amount = 0 [slot 25]
      pushint 0
      store 25 // asset_2_protocol_fee_amount
      // if asset_2_input_amount:
        load 19 // asset_2_input_amount
        bz l17_else
        // then:
          // asset_2_total_fee_amount, asset_2_poolers_fee_amount, asset_2_protocol_fee_amount = calculate_fixed_input_fee_amounts(asset_2_input_amount)
          load 19 // asset_2_input_amount
          callsub __func__calculate_fixed_input_fee_amounts
          store 23 // asset_2_total_fee_amount
          store 24 // asset_2_poolers_fee_amount
          store 25 // asset_2_protocol_fee_amount
          // asset_2_protocol_fees = asset_2_protocol_fees + asset_2_protocol_fee_amount
          load 9 // asset_2_protocol_fees
          load 25 // asset_2_protocol_fee_amount
          +
          store 9 // asset_2_protocol_fees
          // asset_2_reserves = (asset_2_reserves - asset_2_output_amount) + (asset_2_input_amount - asset_2_protocol_fee_amount)
          load 6 // asset_2_reserves
          load 13 // asset_2_output_amount
          -
          load 19 // asset_2_input_amount
          load 25 // asset_2_protocol_fee_amount
          -
          +
          store 6 // asset_2_reserves
        b l17_end
        l17_else:
        // else:
          // asset_2_reserves = asset_2_reserves - asset_2_output_amount
          load 6 // asset_2_reserves
          load 13 // asset_2_output_amount
          -
          store 6 // asset_2_reserves
        l17_end: // end
      
      // check_invariant(asset_1_poolers_fee_amount, asset_2_poolers_fee_amount)
      load 21 // asset_1_poolers_fee_amount
      load 24 // asset_2_poolers_fee_amount
      callsub main__amm__func__check_invariant
      
      // Logs
      // log(concat("asset_1_output_amount %i", itob(asset_1_output_amount)))
      pushbytes "asset_1_output_amount %i"
      load 12 // asset_1_output_amount
      itob
      concat
      log
      // log(concat("asset_1_input_amount %i", itob(asset_1_input_amount)))
      pushbytes "asset_1_input_amount %i"
      load 18 // asset_1_input_amount
      itob
      concat
      log
      // log(concat("asset_1_poolers_fee_amount %i", itob(asset_1_poolers_fee_amount)))
      pushbytes "asset_1_poolers_fee_amount %i"
      load 21 // asset_1_poolers_fee_amount
      itob
      concat
      log
      // log(concat("asset_1_protocol_fee_amount %i", itob(asset_1_protocol_fee_amount)))
      pushbytes "asset_1_protocol_fee_amount %i"
      load 22 // asset_1_protocol_fee_amount
      itob
      concat
      log
      // log(concat("asset_1_total_fee_amount %i", itob(asset_1_total_fee_amount)))
      pushbytes "asset_1_total_fee_amount %i"
      load 20 // asset_1_total_fee_amount
      itob
      concat
      log
      
      // log(concat("asset_2_output_amount %i", itob(asset_2_output_amount)))
      pushbytes "asset_2_output_amount %i"
      load 13 // asset_2_output_amount
      itob
      concat
      log
      // log(concat("asset_2_input_amount %i", itob(asset_2_input_amount)))
      pushbytes "asset_2_input_amount %i"
      load 19 // asset_2_input_amount
      itob
      concat
      log
      // log(concat("asset_2_poolers_fee_amount %i", itob(asset_2_poolers_fee_amount)))
      pushbytes "asset_2_poolers_fee_amount %i"
      load 24 // asset_2_poolers_fee_amount
      itob
      concat
      log
      // log(concat("asset_2_protocol_fee_amount %i", itob(asset_2_protocol_fee_amount)))
      pushbytes "asset_2_protocol_fee_amount %i"
      load 25 // asset_2_protocol_fee_amount
      itob
      concat
      log
      // log(concat("asset_2_total_fee_amount %i", itob(asset_2_total_fee_amount)))
      pushbytes "asset_2_total_fee_amount %i"
      load 23 // asset_2_total_fee_amount
      itob
      concat
      log
      
      // State updates
      // app_local_put(1, "lock", 0)
      pushint 1
      pushbytes "lock"
      pushint 0
      app_local_put
      // app_local_put(1, "asset_1_reserves", asset_1_reserves)
      pushint 1
      pushbytes "asset_1_reserves"
      load 5 // asset_1_reserves
      app_local_put
      // app_local_put(1, "asset_2_reserves", asset_2_reserves)
      pushint 1
      pushbytes "asset_2_reserves"
      load 6 // asset_2_reserves
      app_local_put
      // app_local_put(1, "asset_1_protocol_fees", asset_1_protocol_fees)
      pushint 1
      pushbytes "asset_1_protocol_fees"
      load 8 // asset_1_protocol_fees
      app_local_put
      // app_local_put(1, "asset_2_protocol_fees", asset_2_protocol_fees)
      pushint 1
      pushbytes "asset_2_protocol_fees"
      load 9 // asset_2_protocol_fees
      app_local_put
      // exit(1)
      pushint 1
      return
    
    // block add_liquidity
    main__amm__add_liquidity:
      // Gtxn[N-2]: Transfer Asset1 to Pool from User
      // Gtxn[N-1]: Transfer Asset2 to Pool from User
      // OR
      // Gtxn[N-1]: Transfer Asset1 or Asset2 to Pool from User
      // Gtxn[N]: AppCall from User
      // itxn[0]: Transfer Pool Token to User from Pool
      
      // mode = single | flexible
      // bytes mode = Txn.ApplicationArgs[1] [slot 10]
      txna ApplicationArgs 1
      store 10 // mode
      
      // The minimum expected pool tokens. Should fail if this cannot be achieved.
      // int min_output = btoi(Txn.ApplicationArgs[2]) [slot 11]
      txna ApplicationArgs 2
      btoi
      store 11 // min_output
      
      // Ensure the pool already has some liquidity (from add_initial_liquidity)
      // assert(issued_pool_tokens)
      load 7 // issued_pool_tokens
      assert
      
      // int is_adding_asset_1 = 0 [slot 12]
      pushint 0
      store 12 // is_adding_asset_1
      // int is_adding_asset_2 = 0 [slot 13]
      pushint 0
      store 13 // is_adding_asset_2
      // int asset_1_txn_index [slot 14]
      // int asset_2_txn_index [slot 15]
      // int asset_1_amount = 0 [slot 16]
      pushint 0
      store 16 // asset_1_amount
      // int asset_2_amount = 0 [slot 17]
      pushint 0
      store 17 // asset_2_amount
      // int pool_tokens_out = 0 [slot 18]
      pushint 0
      store 18 // pool_tokens_out
      
      // Increase the app budget
      // increase_cost_budget()
      callsub __func__increase_cost_budget
      
      // Record the current price because the price may be changed by this method
      // update_price_oracle()
      callsub main__amm__func__update_price_oracle
      
      // if mode == "flexible":
        load 10 // mode
        pushbytes "flexible"
        ==
        bz l18_elif_0
        // then:
          // asset_1_txn_index = Txn.GroupIndex - 2
          txn GroupIndex
          pushint 2
          -
          store 14 // asset_1_txn_index
          // asset_2_txn_index = Txn.GroupIndex - 1
          txn GroupIndex
          pushint 1
          -
          store 15 // asset_2_txn_index
          // is_adding_asset_1 = 1
          pushint 1
          store 12 // is_adding_asset_1
          // is_adding_asset_2 = 1
          pushint 1
          store 13 // is_adding_asset_2
        b l18_end
        l18_elif_0:
        // elif mode == "single":
        load 10 // mode
        pushbytes "single"
        ==
        bz l18_else
          // int txn_index = Txn.GroupIndex - 1 [slot 19]
          txn GroupIndex
          pushint 1
          -
          store 19 // txn_index
          // if Gtxn[txn_index].XferAsset == asset_1_id:
            load 19 // txn_index
            gtxns XferAsset
            load 2 // asset_1_id
            ==
            bz l19_elif_0
            // then:
              // asset_1_txn_index = txn_index
              load 19 // txn_index
              store 14 // asset_1_txn_index
              // is_adding_asset_1 = 1
              pushint 1
              store 12 // is_adding_asset_1
            b l19_end
            l19_elif_0:
            // elif Gtxn[txn_index].XferAsset == asset_2_id:
            load 19 // txn_index
            gtxns XferAsset
            load 3 // asset_2_id
            ==
            bz l19_else
              // asset_2_txn_index = txn_index
              load 19 // txn_index
              store 15 // asset_2_txn_index
              // is_adding_asset_2 = 1
              pushint 1
              store 13 // is_adding_asset_2
            b l19_end
            l19_else:
            // else:
              // error()
              err
            l19_end: // end
        b l18_end
        l18_else:
        // else:
          // error()
          err
        l18_end: // end
      
      // if is_adding_asset_1:
        load 12 // is_adding_asset_1
        bz l20_end
        // then:
          // assert(Gtxn[asset_1_txn_index].TypeEnum == Axfer)
          load 14 // asset_1_txn_index
          gtxns TypeEnum
          pushint 4 // Axfer
          ==
          assert
          // assert(Gtxn[asset_1_txn_index].AssetReceiver == pool_address)
          load 14 // asset_1_txn_index
          gtxns AssetReceiver
          load 1 // pool_address
          ==
          assert
          // assert(Gtxn[asset_1_txn_index].XferAsset == asset_1_id)
          load 14 // asset_1_txn_index
          gtxns XferAsset
          load 2 // asset_1_id
          ==
          assert
          // assert(Gtxn[asset_1_txn_index].Sender == user_address)
          load 14 // asset_1_txn_index
          gtxns Sender
          load 0 // user_address
          ==
          assert
          // asset_1_amount = Gtxn[asset_1_txn_index].AssetAmount
          load 14 // asset_1_txn_index
          gtxns AssetAmount
          store 16 // asset_1_amount
        l20_end: // end
      
      // if is_adding_asset_2:
        load 13 // is_adding_asset_2
        bz l21_end
        // then:
          // if asset_2_id == 0:
            load 3 // asset_2_id
            pushint 0
            ==
            bz l22_else
            // then:
              // assert(Gtxn[asset_2_txn_index].TypeEnum == Pay)
              load 15 // asset_2_txn_index
              gtxns TypeEnum
              pushint 1 // Pay
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].Receiver == pool_address)
              load 15 // asset_2_txn_index
              gtxns Receiver
              load 1 // pool_address
              ==
              assert
              // asset_2_amount = Gtxn[asset_2_txn_index].Amount
              load 15 // asset_2_txn_index
              gtxns Amount
              store 17 // asset_2_amount
            b l22_end
            l22_else:
            // else:
              // assert(Gtxn[asset_2_txn_index].TypeEnum == Axfer)
              load 15 // asset_2_txn_index
              gtxns TypeEnum
              pushint 4 // Axfer
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].AssetReceiver == pool_address)
              load 15 // asset_2_txn_index
              gtxns AssetReceiver
              load 1 // pool_address
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].XferAsset == asset_2_id)
              load 15 // asset_2_txn_index
              gtxns XferAsset
              load 3 // asset_2_id
              ==
              assert
              // asset_2_amount = Gtxn[asset_2_txn_index].AssetAmount
              load 15 // asset_2_txn_index
              gtxns AssetAmount
              store 17 // asset_2_amount
            l22_end: // end
          // assert(Gtxn[asset_2_txn_index].Sender == user_address)
          load 15 // asset_2_txn_index
          gtxns Sender
          load 0 // user_address
          ==
          assert
        l21_end: // end
      
      // sqrt_k_per_pool_tokens = sqrt(old_k) / issued_pool_tokens
      // new_issued_pool_tokens = sqrt(new_k) / sqrt_k_per_pool_tokens
      // new_issued_pool_tokens = sqrt(new_k) / (sqrt(old_k) / issued_pool_tokens)
      // new_issued_pool_tokens = sqrt(new_k / old_k) * issued_pool_tokens
      // new_issued_pool_tokens = sqrt((new_k * issued_pool_tokens^2) / old_k)
      // bytes new_k = itob(asset_1_reserves + asset_1_amount) b* itob(asset_2_reserves + asset_2_amount) [slot 20]
      load 5 // asset_1_reserves
      load 16 // asset_1_amount
      +
      itob
      load 6 // asset_2_reserves
      load 17 // asset_2_amount
      +
      itob
      b*
      store 20 // new_k
      // bytes old_k = itob(asset_1_reserves) b* itob(asset_2_reserves) [slot 21]
      load 5 // asset_1_reserves
      itob
      load 6 // asset_2_reserves
      itob
      b*
      store 21 // old_k
      // int new_issued_pool_tokens = btoi(bsqrt(((new_k b* itob(issued_pool_tokens)) b* itob(issued_pool_tokens)) b/ old_k)) [slot 22]
      load 20 // new_k
      load 7 // issued_pool_tokens
      itob
      b*
      load 7 // issued_pool_tokens
      itob
      b*
      load 21 // old_k
      b/
      bsqrt
      btoi
      store 22 // new_issued_pool_tokens
      
      // pool_tokens_out = new_issued_pool_tokens - issued_pool_tokens
      load 22 // new_issued_pool_tokens
      load 7 // issued_pool_tokens
      -
      store 18 // pool_tokens_out
      
      // asset_1_reserves = asset_1_reserves + asset_1_amount
      load 5 // asset_1_reserves
      load 16 // asset_1_amount
      +
      store 5 // asset_1_reserves
      // asset_2_reserves = asset_2_reserves + asset_2_amount
      load 6 // asset_2_reserves
      load 17 // asset_2_amount
      +
      store 6 // asset_2_reserves
      // issued_pool_tokens = new_issued_pool_tokens
      load 22 // new_issued_pool_tokens
      store 7 // issued_pool_tokens
      
      // Determine value of the pool_tokens_out in terms of the two assets:
      // z1 = asset_1_reserves * (pool_tokens_out / issued_pool_tokens)
      // int z1 = btoi((itob(pool_tokens_out) b* itob(asset_1_reserves)) b/ itob(issued_pool_tokens)) [slot 23]
      load 18 // pool_tokens_out
      itob
      load 5 // asset_1_reserves
      itob
      b*
      load 7 // issued_pool_tokens
      itob
      b/
      btoi
      store 23 // z1
      
      // z2 = asset_2_reserves * (pool_tokens_out / issued_pool_tokens)
      // int z2 = btoi((itob(pool_tokens_out) b* itob(asset_2_reserves)) b/ itob(issued_pool_tokens)) [slot 24]
      load 18 // pool_tokens_out
      itob
      load 6 // asset_2_reserves
      itob
      b*
      load 7 // issued_pool_tokens
      itob
      b/
      btoi
      store 24 // z2
      
      // int total_fee_amount [slot 25]
      // int poolers_fee_amount [slot 26]
      // int protocol_fee_amount [slot 27]
      // int fee_as_pool_tokens [slot 28]
      
      // int total_fee_share = app_local_get(1, "total_fee_share") [slot 29]
      pushint 1
      pushbytes "total_fee_share"
      app_local_get
      store 29 // total_fee_share
      // int protocol_fee_ratio = app_local_get(1, "protocol_fee_ratio") [slot 30]
      pushint 1
      pushbytes "protocol_fee_ratio"
      app_local_get
      store 30 // protocol_fee_ratio
      
      // Select the bigger swap amount. Because of the rounding errors both swap amounts can be positive
      // int swap_amount = 0 [slot 31]
      pushint 0
      store 31 // swap_amount
      // int asset_1_to_asset_2 = 1 [slot 32]
      pushint 1
      store 32 // asset_1_to_asset_2
      // if asset_1_amount > z1:
        load 16 // asset_1_amount
        load 23 // z1
        >
        bz l23_end
        // then:
          // swap_amount = asset_1_amount - z1
          load 16 // asset_1_amount
          load 23 // z1
          -
          store 31 // swap_amount
        l23_end: // end
      
      // if asset_2_amount > z2:
        load 17 // asset_2_amount
        load 24 // z2
        >
        bz l24_end
        // then:
          // if swap_amount <= (asset_2_amount - z2):
            load 31 // swap_amount
            load 17 // asset_2_amount
            load 24 // z2
            -
            <=
            bz l25_end
            // then:
              // swap_amount = asset_2_amount - z2
              load 17 // asset_2_amount
              load 24 // z2
              -
              store 31 // swap_amount
              // asset_1_to_asset_2 = 0
              pushint 0
              store 32 // asset_1_to_asset_2
            l25_end: // end
        l24_end: // end
      
      // swap_amount was swapped but no swap fee was charged
      // Determine the fee that should have been charged for a swap of this amount
      // input_amount = (swap_amount * 10000) / (10000 - FEE)
      // total_fee_amount = (input_amount * FEE) / 10000
      // total_fee_amount = (swap_amount * FEE) / (10000 - FEE)
      // total_fee_amount = btoi((itob(swap_amount) b* itob(total_fee_share)) b/ itob((10000 - total_fee_share)))
      load 31 // swap_amount
      itob
      load 29 // total_fee_share
      itob
      b*
      pushint 10000
      load 29 // total_fee_share
      -
      itob
      b/
      btoi
      store 25 // total_fee_amount
      // protocol_fee_amount = total_fee_amount / protocol_fee_ratio
      load 25 // total_fee_amount
      load 30 // protocol_fee_ratio
      /
      store 27 // protocol_fee_amount
      // poolers_fee_amount = total_fee_amount - protocol_fee_amount
      load 25 // total_fee_amount
      load 27 // protocol_fee_amount
      -
      store 26 // poolers_fee_amount
      
      // if asset_1_to_asset_2:
        load 32 // asset_1_to_asset_2
        bz l26_else
        // then:
          // asset_1_protocol_fees = asset_1_protocol_fees + protocol_fee_amount
          load 8 // asset_1_protocol_fees
          load 27 // protocol_fee_amount
          +
          store 8 // asset_1_protocol_fees
          
          // Calculate the fee value as pool tokens
          // fee_as_pool_tokens = ((total_fee_amount / asset_1_reserves) * issued_pool_tokens) / 2
          // fee_as_pool_tokens = btoi((itob(total_fee_amount) b* itob(issued_pool_tokens)) b/ (itob(asset_1_reserves) b* itob(2)))
          load 25 // total_fee_amount
          itob
          load 7 // issued_pool_tokens
          itob
          b*
          load 5 // asset_1_reserves
          itob
          pushint 2
          itob
          b*
          b/
          btoi
          store 28 // fee_as_pool_tokens
          
          // Subtract the protocol fee from asset_1_reserves (the whole of asset_1_amount was added earlier)
          // asset_1_reserves = asset_1_reserves - protocol_fee_amount
          load 5 // asset_1_reserves
          load 27 // protocol_fee_amount
          -
          store 5 // asset_1_reserves
          
          // Logs
          // log(concat("input_asset_id %i", itob(asset_1_id)))
          pushbytes "input_asset_id %i"
          load 2 // asset_1_id
          itob
          concat
          log
          // log(concat("output_asset_id %i", itob(asset_2_id)))
          pushbytes "output_asset_id %i"
          load 3 // asset_2_id
          itob
          concat
          log
        b l26_end
        l26_else:
        // else:
          // asset_2_protocol_fees = asset_2_protocol_fees + protocol_fee_amount
          load 9 // asset_2_protocol_fees
          load 27 // protocol_fee_amount
          +
          store 9 // asset_2_protocol_fees
          
          // Calculate the fee value as pool tokens
          // fee_as_pool_tokens = ((total_fee_amount / asset_2_reserves) * issued_pool_tokens) / 2
          // fee_as_pool_tokens = btoi((itob(total_fee_amount) b* itob(issued_pool_tokens)) b/ (itob(asset_2_reserves) b* itob(2)))
          load 25 // total_fee_amount
          itob
          load 7 // issued_pool_tokens
          itob
          b*
          load 6 // asset_2_reserves
          itob
          pushint 2
          itob
          b*
          b/
          btoi
          store 28 // fee_as_pool_tokens
          
          // Subtract the protocol fee from asset_2_reserves (the whole of asset_2_amount was added earlier)
          // asset_2_reserves = asset_2_reserves - protocol_fee_amount
          load 6 // asset_2_reserves
          load 27 // protocol_fee_amount
          -
          store 6 // asset_2_reserves
          
          // Logs
          // log(concat("input_asset_id %i", itob(asset_2_id)))
          pushbytes "input_asset_id %i"
          load 3 // asset_2_id
          itob
          concat
          log
          // log(concat("output_asset_id %i", itob(asset_1_id)))
          pushbytes "output_asset_id %i"
          load 2 // asset_1_id
          itob
          concat
          log
        l26_end: // end
      
      // Subtract the fee from the outgoing pool tokens
      // pool_tokens_out = pool_tokens_out - fee_as_pool_tokens
      load 18 // pool_tokens_out
      load 28 // fee_as_pool_tokens
      -
      store 18 // pool_tokens_out
      // issued_pool_tokens = issued_pool_tokens - fee_as_pool_tokens
      load 7 // issued_pool_tokens
      load 28 // fee_as_pool_tokens
      -
      store 7 // issued_pool_tokens
      
      // Ensure calculated amount of pool tokens is > 0
      // assert(pool_tokens_out)
      load 18 // pool_tokens_out
      assert
      
      // Ensure calculated amount of pool tokens is greater or equal to the expected min amount
      // assert(pool_tokens_out >= min_output)
      load 18 // pool_tokens_out
      load 11 // min_output
      >=
      assert
      
      // Send pool tokens to liquidity provider
      // transfer_to_user(pool_token_asset_id, pool_tokens_out)
      load 4 // pool_token_asset_id
      load 18 // pool_tokens_out
      callsub main__amm__func__transfer_to_user
      
      // check_pool_token_value()
      callsub main__amm__func__check_pool_token_value
      
      // Logs
      // log(concat("swap_amount %i", itob(swap_amount)))
      pushbytes "swap_amount %i"
      load 31 // swap_amount
      itob
      concat
      log
      // log(concat("poolers_fee_amount %i", itob(poolers_fee_amount)))
      pushbytes "poolers_fee_amount %i"
      load 26 // poolers_fee_amount
      itob
      concat
      log
      // log(concat("protocol_fee_amount %i", itob(protocol_fee_amount)))
      pushbytes "protocol_fee_amount %i"
      load 27 // protocol_fee_amount
      itob
      concat
      log
      // log(concat("total_fee_amount %i", itob(total_fee_amount)))
      pushbytes "total_fee_amount %i"
      load 25 // total_fee_amount
      itob
      concat
      log
      
      // State updates
      // app_local_put(1, "asset_1_reserves", asset_1_reserves)
      pushint 1
      pushbytes "asset_1_reserves"
      load 5 // asset_1_reserves
      app_local_put
      // app_local_put(1, "asset_2_reserves", asset_2_reserves)
      pushint 1
      pushbytes "asset_2_reserves"
      load 6 // asset_2_reserves
      app_local_put
      // app_local_put(1, "issued_pool_tokens", issued_pool_tokens)
      pushint 1
      pushbytes "issued_pool_tokens"
      load 7 // issued_pool_tokens
      app_local_put
      // app_local_put(1, "asset_1_protocol_fees", asset_1_protocol_fees)
      pushint 1
      pushbytes "asset_1_protocol_fees"
      load 8 // asset_1_protocol_fees
      app_local_put
      // app_local_put(1, "asset_2_protocol_fees", asset_2_protocol_fees)
      pushint 1
      pushbytes "asset_2_protocol_fees"
      load 9 // asset_2_protocol_fees
      app_local_put
      // exit(1)
      pushint 1
      return
    
    // block add_initial_liquidity
    main__amm__add_initial_liquidity:
      // Gtxn[N-2]: Transfer Asset1 to Pool from User
      // Gtxn[N-1]: Transfer Asset2 to Pool from User
      // Gtxn[N]: AppCall from User
      // itxn[0]: Transfer Pool Token to User from Pool
      
      // int asset_1_txn_index [slot 10]
      // int asset_2_txn_index [slot 11]
      // int asset_1_amount = 0 [slot 12]
      pushint 0
      store 12 // asset_1_amount
      // int asset_2_amount = 0 [slot 13]
      pushint 0
      store 13 // asset_2_amount
      // int pool_tokens_out = 0 [slot 14]
      pushint 0
      store 14 // pool_tokens_out
      
      // Make sure this really is an empty pool
      // assert(issued_pool_tokens == 0)
      load 7 // issued_pool_tokens
      pushint 0
      ==
      assert
      
      // asset_1_txn_index = Txn.GroupIndex - 2
      txn GroupIndex
      pushint 2
      -
      store 10 // asset_1_txn_index
      // asset_2_txn_index = Txn.GroupIndex - 1
      txn GroupIndex
      pushint 1
      -
      store 11 // asset_2_txn_index
      
      // assert(Gtxn[asset_1_txn_index].TypeEnum == Axfer)
      load 10 // asset_1_txn_index
      gtxns TypeEnum
      pushint 4 // Axfer
      ==
      assert
      // assert(Gtxn[asset_1_txn_index].AssetReceiver == pool_address)
      load 10 // asset_1_txn_index
      gtxns AssetReceiver
      load 1 // pool_address
      ==
      assert
      // assert(Gtxn[asset_1_txn_index].XferAsset == asset_1_id)
      load 10 // asset_1_txn_index
      gtxns XferAsset
      load 2 // asset_1_id
      ==
      assert
      // assert(Gtxn[asset_1_txn_index].Sender == user_address)
      load 10 // asset_1_txn_index
      gtxns Sender
      load 0 // user_address
      ==
      assert
      // asset_1_amount = Gtxn[asset_1_txn_index].AssetAmount
      load 10 // asset_1_txn_index
      gtxns AssetAmount
      store 12 // asset_1_amount
      // assert(asset_1_amount)
      load 12 // asset_1_amount
      assert
      
      // if asset_2_id == 0:
        load 3 // asset_2_id
        pushint 0
        ==
        bz l27_else
        // then:
          // assert(Gtxn[asset_2_txn_index].TypeEnum == Pay)
          load 11 // asset_2_txn_index
          gtxns TypeEnum
          pushint 1 // Pay
          ==
          assert
          // assert(Gtxn[asset_2_txn_index].Receiver == pool_address)
          load 11 // asset_2_txn_index
          gtxns Receiver
          load 1 // pool_address
          ==
          assert
          // asset_2_amount = Gtxn[asset_2_txn_index].Amount
          load 11 // asset_2_txn_index
          gtxns Amount
          store 13 // asset_2_amount
        b l27_end
        l27_else:
        // else:
          // assert(Gtxn[asset_2_txn_index].TypeEnum == Axfer)
          load 11 // asset_2_txn_index
          gtxns TypeEnum
          pushint 4 // Axfer
          ==
          assert
          // assert(Gtxn[asset_2_txn_index].AssetReceiver == pool_address)
          load 11 // asset_2_txn_index
          gtxns AssetReceiver
          load 1 // pool_address
          ==
          assert
          // assert(Gtxn[asset_2_txn_index].XferAsset == asset_2_id)
          load 11 // asset_2_txn_index
          gtxns XferAsset
          load 3 // asset_2_id
          ==
          assert
          // asset_2_amount = Gtxn[asset_2_txn_index].AssetAmount
          load 11 // asset_2_txn_index
          gtxns AssetAmount
          store 13 // asset_2_amount
        l27_end: // end
      // assert(asset_2_amount)
      load 13 // asset_2_amount
      assert
      // assert(Gtxn[asset_2_txn_index].Sender == user_address)
      load 11 // asset_2_txn_index
      gtxns Sender
      load 0 // user_address
      ==
      assert
      
      // pool_tokens_out = sqrt(asset_1_amount * asset_2_amount) - LOCKED_POOL_TOKENS
      // issued_pool_tokens = btoi(bsqrt(itob(asset_1_amount) b* itob(asset_2_amount)))
      load 12 // asset_1_amount
      itob
      load 13 // asset_2_amount
      itob
      b*
      bsqrt
      btoi
      store 7 // issued_pool_tokens
      // assert(issued_pool_tokens > LOCKED_POOL_TOKENS)
      load 7 // issued_pool_tokens
      pushint 1000 // LOCKED_POOL_TOKENS
      >
      assert
      // pool_tokens_out = issued_pool_tokens - LOCKED_POOL_TOKENS
      load 7 // issued_pool_tokens
      pushint 1000 // LOCKED_POOL_TOKENS
      -
      store 14 // pool_tokens_out
      
      // Send pool tokens to liquidity provider
      // transfer_to_user(pool_token_asset_id, pool_tokens_out)
      load 4 // pool_token_asset_id
      load 14 // pool_tokens_out
      callsub main__amm__func__transfer_to_user
      
      // State updates
      // app_local_put(1, "asset_1_reserves", asset_1_amount)
      pushint 1
      pushbytes "asset_1_reserves"
      load 12 // asset_1_amount
      app_local_put
      // app_local_put(1, "asset_2_reserves", asset_2_amount)
      pushint 1
      pushbytes "asset_2_reserves"
      load 13 // asset_2_amount
      app_local_put
      // app_local_put(1, "issued_pool_tokens", issued_pool_tokens)
      pushint 1
      pushbytes "issued_pool_tokens"
      load 7 // issued_pool_tokens
      app_local_put
      // exit(1)
      pushint 1
      return
    
    // block remove_liquidity
    main__amm__remove_liquidity:
      // Gtxn[N-1]: Transfer Pool Token to Pool from User
      // Gtxn[N]: AppCall from User
      // itxn[0]: Transfer Asset 1 to User from Pool
      // itxn[1]: Transfer Asset 2 to User from Pool
      // or
      // itxn[0]: Transfer Asset {1 or 2} to User from Pool
      
      // Record the current price because the price may be changed by this method
      // update_price_oracle()
      callsub main__amm__func__update_price_oracle
      
      // The minimum expected amount out of each asset. Should fail if these cannot be achieved.
      // int min_output_1 = btoi(Txn.ApplicationArgs[1]) [slot 10]
      txna ApplicationArgs 1
      btoi
      store 10 // min_output_1
      // int min_output_2 = btoi(Txn.ApplicationArgs[2]) [slot 11]
      txna ApplicationArgs 2
      btoi
      store 11 // min_output_2
      
      // int pool_token_txn_index = Txn.GroupIndex - 1 [slot 12]
      txn GroupIndex
      pushint 1
      -
      store 12 // pool_token_txn_index
      // assert(Gtxn[pool_token_txn_index].TypeEnum == Axfer)
      load 12 // pool_token_txn_index
      gtxns TypeEnum
      pushint 4 // Axfer
      ==
      assert
      // assert(Gtxn[pool_token_txn_index].AssetReceiver == pool_address)
      load 12 // pool_token_txn_index
      gtxns AssetReceiver
      load 1 // pool_address
      ==
      assert
      // assert(Gtxn[pool_token_txn_index].XferAsset == pool_token_asset_id)
      load 12 // pool_token_txn_index
      gtxns XferAsset
      load 4 // pool_token_asset_id
      ==
      assert
      // assert(Gtxn[pool_token_txn_index].Sender == user_address)
      load 12 // pool_token_txn_index
      gtxns Sender
      load 0 // user_address
      ==
      assert
      // int removed_pool_token_amount = Gtxn[pool_token_txn_index].AssetAmount [slot 13]
      load 12 // pool_token_txn_index
      gtxns AssetAmount
      store 13 // removed_pool_token_amount
      
      // int asset_1_amount [slot 14]
      // int asset_2_amount [slot 15]
      // if (removed_pool_token_amount + LOCKED_POOL_TOKENS) == issued_pool_tokens:
        load 13 // removed_pool_token_amount
        pushint 1000 // LOCKED_POOL_TOKENS
        +
        load 7 // issued_pool_tokens
        ==
        bz l28_else
        // then:
          // asset_1_amount = asset_1_reserves
          load 5 // asset_1_reserves
          store 14 // asset_1_amount
          // asset_2_amount = asset_2_reserves
          load 6 // asset_2_reserves
          store 15 // asset_2_amount
          // issued_pool_tokens = 0
          pushint 0
          store 7 // issued_pool_tokens
        b l28_end
        l28_else:
        // else:
          // asset_1_amount = btoi((itob(removed_pool_token_amount) b* itob(asset_1_reserves)) b/ itob(issued_pool_tokens))
          load 13 // removed_pool_token_amount
          itob
          load 5 // asset_1_reserves
          itob
          b*
          load 7 // issued_pool_tokens
          itob
          b/
          btoi
          store 14 // asset_1_amount
          // asset_2_amount = btoi((itob(removed_pool_token_amount) b* itob(asset_2_reserves)) b/ itob(issued_pool_tokens))
          load 13 // removed_pool_token_amount
          itob
          load 6 // asset_2_reserves
          itob
          b*
          load 7 // issued_pool_tokens
          itob
          b/
          btoi
          store 15 // asset_2_amount
          // issued_pool_tokens = issued_pool_tokens - removed_pool_token_amount
          load 7 // issued_pool_tokens
          load 13 // removed_pool_token_amount
          -
          store 7 // issued_pool_tokens
        l28_end: // end
      
      // assert(asset_1_amount && asset_2_amount)
      load 14 // asset_1_amount
      load 15 // asset_2_amount
      &&
      assert
      
      // asset_1_reserves = asset_1_reserves - asset_1_amount
      load 5 // asset_1_reserves
      load 14 // asset_1_amount
      -
      store 5 // asset_1_reserves
      // asset_2_reserves = asset_2_reserves - asset_2_amount
      load 6 // asset_2_reserves
      load 15 // asset_2_amount
      -
      store 6 // asset_2_reserves
      
      // int total_fee_amount [slot 16]
      // int poolers_fee_amount [slot 17]
      // int protocol_fee_amount [slot 18]
      // int swap_amount [slot 19]
      // int swap_output_amount [slot 20]
      // if Txn.NumAssets == 2:
        txn NumAssets
        pushint 2
        ==
        bz l29_elif_0
        // then:
          // Removing liquidity with 2 assets
          // assert(Txn.Assets[0] == asset_1_id)
          txna Assets 0
          load 2 // asset_1_id
          ==
          assert
          // assert(Txn.Assets[1] == asset_2_id)
          txna Assets 1
          load 3 // asset_2_id
          ==
          assert
          // assert(asset_1_amount >= min_output_1)
          load 14 // asset_1_amount
          load 10 // min_output_1
          >=
          assert
          // assert(asset_2_amount >= min_output_2)
          load 15 // asset_2_amount
          load 11 // min_output_2
          >=
          assert
          // transfer_to_user(asset_1_id, asset_1_amount)
          load 2 // asset_1_id
          load 14 // asset_1_amount
          callsub main__amm__func__transfer_to_user
          // transfer_to_user(asset_2_id, asset_2_amount)
          load 3 // asset_2_id
          load 15 // asset_2_amount
          callsub main__amm__func__transfer_to_user
        b l29_end
        l29_elif_0:
        // elif (Txn.NumAssets == 1):
        txn NumAssets
        pushint 1
        ==
        bz l29_else
          // Increase the app budget
          // increase_cost_budget()
          callsub __func__increase_cost_budget
          // assert(issued_pool_tokens > 0)
          load 7 // issued_pool_tokens
          pushint 0
          >
          assert
          // Removing liquidity with 1 asset
          // int final_output_amount = 0 [slot 21]
          pushint 0
          store 21 // final_output_amount
          // if Txn.Assets[0] == asset_1_id:
            txna Assets 0
            load 2 // asset_1_id
            ==
            bz l30_elif_0
            // then:
              // total_fee_amount, poolers_fee_amount, protocol_fee_amount = calculate_fixed_input_fee_amounts(asset_2_amount)
              load 15 // asset_2_amount
              callsub __func__calculate_fixed_input_fee_amounts
              store 16 // total_fee_amount
              store 17 // poolers_fee_amount
              store 18 // protocol_fee_amount
              // swap_amount = asset_2_amount - total_fee_amount
              load 15 // asset_2_amount
              load 16 // total_fee_amount
              -
              store 19 // swap_amount
              // swap_output_amount = calculate_fixed_input_swap(asset_2_reserves, asset_1_reserves, swap_amount)
              load 6 // asset_2_reserves
              load 5 // asset_1_reserves
              load 19 // swap_amount
              callsub __func__calculate_fixed_input_swap
              store 20 // swap_output_amount
              // asset_1_reserves = asset_1_reserves - swap_output_amount
              load 5 // asset_1_reserves
              load 20 // swap_output_amount
              -
              store 5 // asset_1_reserves
              // asset_2_reserves = asset_2_reserves + (swap_amount + poolers_fee_amount)
              load 6 // asset_2_reserves
              load 19 // swap_amount
              load 17 // poolers_fee_amount
              +
              +
              store 6 // asset_2_reserves
              // asset_2_protocol_fees = asset_2_protocol_fees + protocol_fee_amount
              load 9 // asset_2_protocol_fees
              load 18 // protocol_fee_amount
              +
              store 9 // asset_2_protocol_fees
              // final_output_amount = asset_1_amount + swap_output_amount
              load 14 // asset_1_amount
              load 20 // swap_output_amount
              +
              store 21 // final_output_amount
              // assert(final_output_amount >= min_output_1)
              load 21 // final_output_amount
              load 10 // min_output_1
              >=
              assert
              // transfer_to_user(asset_1_id, final_output_amount)
              load 2 // asset_1_id
              load 21 // final_output_amount
              callsub main__amm__func__transfer_to_user
              
              // Logs
              // log(concat("input_asset_id %i", itob(asset_2_id)))
              pushbytes "input_asset_id %i"
              load 3 // asset_2_id
              itob
              concat
              log
              // log(concat("input_amount %i", itob(asset_2_amount)))
              pushbytes "input_amount %i"
              load 15 // asset_2_amount
              itob
              concat
              log
              // log(concat("swap_amount %i", itob(swap_amount)))
              pushbytes "swap_amount %i"
              load 19 // swap_amount
              itob
              concat
              log
              
              // log(concat("output_asset_id %i", itob(asset_1_id)))
              pushbytes "output_asset_id %i"
              load 2 // asset_1_id
              itob
              concat
              log
              // log(concat("output_amount %i", itob(swap_output_amount)))
              pushbytes "output_amount %i"
              load 20 // swap_output_amount
              itob
              concat
              log
            b l30_end
            l30_elif_0:
            // elif Txn.Assets[0] == asset_2_id:
            txna Assets 0
            load 3 // asset_2_id
            ==
            bz l30_else
              // total_fee_amount, poolers_fee_amount, protocol_fee_amount = calculate_fixed_input_fee_amounts(asset_1_amount)
              load 14 // asset_1_amount
              callsub __func__calculate_fixed_input_fee_amounts
              store 16 // total_fee_amount
              store 17 // poolers_fee_amount
              store 18 // protocol_fee_amount
              // swap_amount = asset_1_amount - total_fee_amount
              load 14 // asset_1_amount
              load 16 // total_fee_amount
              -
              store 19 // swap_amount
              // swap_output_amount = calculate_fixed_input_swap(asset_1_reserves, asset_2_reserves, swap_amount)
              load 5 // asset_1_reserves
              load 6 // asset_2_reserves
              load 19 // swap_amount
              callsub __func__calculate_fixed_input_swap
              store 20 // swap_output_amount
              // asset_2_reserves = asset_2_reserves - swap_output_amount
              load 6 // asset_2_reserves
              load 20 // swap_output_amount
              -
              store 6 // asset_2_reserves
              // asset_1_reserves = asset_1_reserves + (swap_amount + poolers_fee_amount)
              load 5 // asset_1_reserves
              load 19 // swap_amount
              load 17 // poolers_fee_amount
              +
              +
              store 5 // asset_1_reserves
              // asset_1_protocol_fees = asset_1_protocol_fees + protocol_fee_amount
              load 8 // asset_1_protocol_fees
              load 18 // protocol_fee_amount
              +
              store 8 // asset_1_protocol_fees
              // final_output_amount = asset_2_amount + swap_output_amount
              load 15 // asset_2_amount
              load 20 // swap_output_amount
              +
              store 21 // final_output_amount
              // assert(final_output_amount >= min_output_2)
              load 21 // final_output_amount
              load 11 // min_output_2
              >=
              assert
              // transfer_to_user(asset_2_id, final_output_amount)
              load 3 // asset_2_id
              load 21 // final_output_amount
              callsub main__amm__func__transfer_to_user
              
              // Logs
              // log(concat("input_asset_id %i", itob(asset_1_id)))
              pushbytes "input_asset_id %i"
              load 2 // asset_1_id
              itob
              concat
              log
              // log(concat("input_amount %i", itob(asset_1_amount)))
              pushbytes "input_amount %i"
              load 14 // asset_1_amount
              itob
              concat
              log
              // log(concat("swap_amount %i", itob(swap_amount)))
              pushbytes "swap_amount %i"
              load 19 // swap_amount
              itob
              concat
              log
              
              // log(concat("output_asset_id %i", itob(asset_2_id)))
              pushbytes "output_asset_id %i"
              load 3 // asset_2_id
              itob
              concat
              log
              // log(concat("output_amount %i", itob(swap_output_amount)))
              pushbytes "output_amount %i"
              load 20 // swap_output_amount
              itob
              concat
              log
            b l30_end
            l30_else:
            // else:
              // error()
              err
            l30_end: // end
          
          // Logs
          // log(concat("poolers_fee_amount %i", itob(poolers_fee_amount)))
          pushbytes "poolers_fee_amount %i"
          load 17 // poolers_fee_amount
          itob
          concat
          log
          // log(concat("protocol_fee_amount %i", itob(protocol_fee_amount)))
          pushbytes "protocol_fee_amount %i"
          load 18 // protocol_fee_amount
          itob
          concat
          log
          // log(concat("total_fee_amount %i", itob(total_fee_amount)))
          pushbytes "total_fee_amount %i"
          load 16 // total_fee_amount
          itob
          concat
          log
        b l29_end
        l29_else:
        // else:
          // error()
          err
        l29_end: // end
      
      // if issued_pool_tokens:
        load 7 // issued_pool_tokens
        bz l31_end
        // then:
          // check_pool_token_value()
          callsub main__amm__func__check_pool_token_value
        l31_end: // end
      
      // State updates
      // app_local_put(1, "asset_1_reserves", asset_1_reserves)
      pushint 1
      pushbytes "asset_1_reserves"
      load 5 // asset_1_reserves
      app_local_put
      // app_local_put(1, "asset_2_reserves", asset_2_reserves)
      pushint 1
      pushbytes "asset_2_reserves"
      load 6 // asset_2_reserves
      app_local_put
      // app_local_put(1, "issued_pool_tokens", issued_pool_tokens)
      pushint 1
      pushbytes "issued_pool_tokens"
      load 7 // issued_pool_tokens
      app_local_put
      // app_local_put(1, "asset_1_protocol_fees", asset_1_protocol_fees)
      pushint 1
      pushbytes "asset_1_protocol_fees"
      load 8 // asset_1_protocol_fees
      app_local_put
      // app_local_put(1, "asset_2_protocol_fees", asset_2_protocol_fees)
      pushint 1
      pushbytes "asset_2_protocol_fees"
      load 9 // asset_2_protocol_fees
      app_local_put
      // exit(1)
      pushint 1
      return
    
    // func transfer_to_user(asset_id: int, amount: int):
    main__amm__func__transfer_to_user:
    store 33 // amount
    store 34 // asset_id
    // return transfer(asset_id, amount, pool_address, user_address)
    load 34 // asset_id
    load 33 // amount
    load 1 // pool_address
    load 0 // user_address
    callsub __func__transfer
    retsub
    
    // func check_invariant(asset_1_poolers_fee_amount: int, asset_2_poolers_fee_amount: int):
    main__amm__func__check_invariant:
    store 35 // asset_2_poolers_fee_amount
    store 36 // asset_1_poolers_fee_amount
    // Initial K < Final K without fees
    // assert((itob(app_local_get(1, "asset_1_reserves")) b* itob(app_local_get(1, "asset_2_reserves"))) b<= (itob(asset_1_reserves - asset_1_poolers_fee_amount) b* itob(asset_2_reserves - asset_2_poolers_fee_amount)))
    pushint 1
    pushbytes "asset_1_reserves"
    app_local_get
    itob
    pushint 1
    pushbytes "asset_2_reserves"
    app_local_get
    itob
    b*
    load 5 // asset_1_reserves
    load 36 // asset_1_poolers_fee_amount
    -
    itob
    load 6 // asset_2_reserves
    load 35 // asset_2_poolers_fee_amount
    -
    itob
    b*
    b<=
    assert
    // return
    retsub
    
    // func check_pool_token_value():
    main__amm__func__check_pool_token_value:
    // (sqrt(initial_k) / initial_issued_pool_tokens) <= (sqrt(final_k) / final_issued_pool_tokens)
    // (initial_k * final_issued_pool_tokens**2) <= (final_k * initial_issued_pool_tokens**2)
    // bytes tmp_initial = (itob(app_local_get(1, "asset_1_reserves")) b* itob(app_local_get(1, "asset_2_reserves"))) b* (itob(issued_pool_tokens) b* itob(issued_pool_tokens)) [slot 37]
    pushint 1
    pushbytes "asset_1_reserves"
    app_local_get
    itob
    pushint 1
    pushbytes "asset_2_reserves"
    app_local_get
    itob
    b*
    load 7 // issued_pool_tokens
    itob
    load 7 // issued_pool_tokens
    itob
    b*
    b*
    store 37 // tmp_initial
    // bytes tmp_final = (itob(asset_1_reserves) b* itob(asset_2_reserves)) b* (itob(app_local_get(1, "issued_pool_tokens")) b* itob(app_local_get(1, "issued_pool_tokens"))) [slot 38]
    load 5 // asset_1_reserves
    itob
    load 6 // asset_2_reserves
    itob
    b*
    pushint 1
    pushbytes "issued_pool_tokens"
    app_local_get
    itob
    pushint 1
    pushbytes "issued_pool_tokens"
    app_local_get
    itob
    b*
    b*
    store 38 // tmp_final
    // assert(tmp_initial b<= tmp_final)
    load 37 // tmp_initial
    load 38 // tmp_final
    b<=
    assert
    // return
    retsub
    
    // func update_price_oracle():
    main__amm__func__update_price_oracle:
    // bytes asset_1_cumulative_price = app_local_get(1, "asset_1_cumulative_price") [slot 39]
    pushint 1
    pushbytes "asset_1_cumulative_price"
    app_local_get
    store 39 // asset_1_cumulative_price
    // bytes asset_2_cumulative_price = app_local_get(1, "asset_2_cumulative_price") [slot 40]
    pushint 1
    pushbytes "asset_2_cumulative_price"
    app_local_get
    store 40 // asset_2_cumulative_price
    // int time_delta = Global.LatestTimestamp - app_local_get(1, "cumulative_price_update_timestamp") [slot 41]
    global LatestTimestamp
    pushint 1
    pushbytes "cumulative_price_update_timestamp"
    app_local_get
    -
    store 41 // time_delta
    
    // if (issued_pool_tokens && time_delta):
      load 7 // issued_pool_tokens
      load 41 // time_delta
      &&
      bz l32_end
      // then:
        // asset_1_cumulative_price = asset_1_cumulative_price b+ (((itob(asset_2_reserves) b* TWO_TO_THE_64) b* itob(time_delta)) b/ itob(asset_1_reserves))
        load 39 // asset_1_cumulative_price
        load 6 // asset_2_reserves
        itob
        pushbytes "\x01\x00\x00\x00\x00\x00\x00\x00\x00" // TWO_TO_THE_64
        b*
        load 41 // time_delta
        itob
        b*
        load 5 // asset_1_reserves
        itob
        b/
        b+
        store 39 // asset_1_cumulative_price
        // asset_2_cumulative_price = asset_2_cumulative_price b+ (((itob(asset_1_reserves) b* TWO_TO_THE_64) b* itob(time_delta)) b/ itob(asset_2_reserves))
        load 40 // asset_2_cumulative_price
        load 5 // asset_1_reserves
        itob
        pushbytes "\x01\x00\x00\x00\x00\x00\x00\x00\x00" // TWO_TO_THE_64
        b*
        load 41 // time_delta
        itob
        b*
        load 6 // asset_2_reserves
        itob
        b/
        b+
        store 40 // asset_2_cumulative_price
        // app_local_put(1, "asset_1_cumulative_price", asset_1_cumulative_price)
        pushint 1
        pushbytes "asset_1_cumulative_price"
        load 39 // asset_1_cumulative_price
        app_local_put
        // app_local_put(1, "asset_2_cumulative_price", asset_2_cumulative_price)
        pushint 1
        pushbytes "asset_2_cumulative_price"
        load 40 // asset_2_cumulative_price
        app_local_put
        // app_local_put(1, "cumulative_price_update_timestamp", Global.LatestTimestamp)
        pushint 1
        pushbytes "cumulative_price_update_timestamp"
        global LatestTimestamp
        app_local_put
      l32_end: // end
    // return
    retsub

// func calculate_fixed_input_fee_amounts(input_amount: int) int, int, int:
__func__calculate_fixed_input_fee_amounts:
store 42 // input_amount
// int total_fee_share = app_local_get(1, "total_fee_share") [slot 43]
pushint 1
pushbytes "total_fee_share"
app_local_get
store 43 // total_fee_share
// int protocol_fee_ratio = app_local_get(1, "protocol_fee_ratio") [slot 44]
pushint 1
pushbytes "protocol_fee_ratio"
app_local_get
store 44 // protocol_fee_ratio

// int total_fee = (input_amount * total_fee_share) / 10000 [slot 45]
load 42 // input_amount
load 43 // total_fee_share
*
pushint 10000
/
store 45 // total_fee
// int protocol_fee = total_fee / protocol_fee_ratio [slot 46]
load 45 // total_fee
load 44 // protocol_fee_ratio
/
store 46 // protocol_fee
// int poolers_fee = total_fee - protocol_fee [slot 47]
load 45 // total_fee
load 46 // protocol_fee
-
store 47 // poolers_fee
// return total_fee, poolers_fee, protocol_fee
load 46 // protocol_fee
load 47 // poolers_fee
load 45 // total_fee
retsub

// func calculate_fixed_output_fee_amounts(swap_amount: int) int, int, int:
__func__calculate_fixed_output_fee_amounts:
store 48 // swap_amount
// int total_fee_share = app_local_get(1, "total_fee_share") [slot 49]
pushint 1
pushbytes "total_fee_share"
app_local_get
store 49 // total_fee_share
// int protocol_fee_ratio = app_local_get(1, "protocol_fee_ratio") [slot 50]
pushint 1
pushbytes "protocol_fee_ratio"
app_local_get
store 50 // protocol_fee_ratio
// int input_amount = (swap_amount * 10000) / (10000 - total_fee_share) [slot 51]
load 48 // swap_amount
pushint 10000
*
pushint 10000
load 49 // total_fee_share
-
/
store 51 // input_amount

// int total_fee = input_amount - swap_amount [slot 52]
load 51 // input_amount
load 48 // swap_amount
-
store 52 // total_fee
// int protocol_fee = total_fee / protocol_fee_ratio [slot 53]
load 52 // total_fee
load 50 // protocol_fee_ratio
/
store 53 // protocol_fee
// int poolers_fee = total_fee - protocol_fee [slot 54]
load 52 // total_fee
load 53 // protocol_fee
-
store 54 // poolers_fee
// return total_fee, poolers_fee, protocol_fee
load 53 // protocol_fee
load 54 // poolers_fee
load 52 // total_fee
retsub

// func calculate_fixed_input_swap(input_supply: int, output_supply: int, swap_amount: int) int:
__func__calculate_fixed_input_swap:
store 55 // swap_amount
store 56 // output_supply
store 57 // input_supply
// Calculates the output amount for a fixed-input swap ignoring fees
// k = input_supply * output_supply
// output_amount = output_supply - (k / (input_supply + swap_amount))
// bytes k = itob(input_supply) b* itob(output_supply) [slot 58]
load 57 // input_supply
itob
load 56 // output_supply
itob
b*
store 58 // k
// +1 for Round Up
// int output_amount = output_supply - (btoi((k b/ itob(input_supply + swap_amount))) + 1) [slot 59]
load 56 // output_supply
load 58 // k
load 57 // input_supply
load 55 // swap_amount
+
itob
b/
btoi
pushint 1
+
-
store 59 // output_amount
// return output_amount
load 59 // output_amount
retsub

// func calculate_fixed_output_swap(input_supply: int, output_supply: int, output_amount: int) int:
__func__calculate_fixed_output_swap:
store 60 // output_amount
store 61 // output_supply
store 62 // input_supply
// Calculates the input amount for a fixed-output swap ignoring fees
// k = input_supply * output_supply
// swap_amount = (k / (output_supply - asset_output_amount)) - input_supply
// bytes k = itob(input_supply) b* itob(output_supply) [slot 63]
load 62 // input_supply
itob
load 61 // output_supply
itob
b*
store 63 // k
// +1 for Round Up
// int swap_amount = (btoi((k b/ itob(output_supply - output_amount))) + 1) - input_supply [slot 64]
load 63 // k
load 61 // output_supply
load 60 // output_amount
-
itob
b/
btoi
pushint 1
+
load 62 // input_supply
-
store 64 // swap_amount
// return swap_amount
load 64 // swap_amount
retsub

// func get_balance(account_idx: int, asset_id: int) int:
__func__get_balance:
store 65 // asset_id
store 66 // account_idx
// int balance = 0 [slot 67]
pushint 0
store 67 // balance
// if asset_id == 0:
  load 65 // asset_id
  pushint 0
  ==
  bz l33_else
  // then:
    // balance = balance(account_idx) - min_balance(account_idx)
    load 66 // account_idx
    balance
    load 66 // account_idx
    min_balance
    -
    store 67 // balance
  b l33_end
  l33_else:
  // else:
    // _, balance = asset_holding_get(AssetBalance, account_idx, asset_id)
    load 66 // account_idx
    load 65 // asset_id
    asset_holding_get AssetBalance
    pop // discarding value for _
    store 67 // balance
  l33_end: // end
// return balance
load 67 // balance
retsub

// func transfer(asset_id: int, amount: int, sender: bytes, receiver: bytes):
__func__transfer:
store 68 // receiver
store 69 // sender
store 70 // amount
store 71 // asset_id
// if asset_id == 0:
  load 71 // asset_id
  pushint 0
  ==
  bz l34_else
  // then:
    // 
    itxn_begin
    // inner_txn:
    pushint 1 // Pay
    itxn_field TypeEnum
    load 69 // sender
    itxn_field Sender
    load 68 // receiver
    itxn_field Receiver
    load 70 // amount
    itxn_field Amount
    pushint 0
    itxn_field Fee
    itxn_submit
  b l34_end
  l34_else:
  // else:
    // 
    itxn_begin
    // inner_txn:
    pushint 4 // Axfer
    itxn_field TypeEnum
    load 69 // sender
    itxn_field Sender
    load 68 // receiver
    itxn_field AssetReceiver
    load 70 // amount
    itxn_field AssetAmount
    load 71 // asset_id
    itxn_field XferAsset
    pushint 0
    itxn_field Fee
    itxn_submit
  l34_end: // end
// return
retsub

// func increase_cost_budget():
__func__increase_cost_budget:
// Increase the cost budget by making an app call that creates and deletes an application immediately
// 
itxn_begin
// inner_txn:
pushint 6 // Appl
itxn_field TypeEnum
pushint 5 // DeleteApplication
itxn_field OnCompletion
pushbytes "\x06\x81\x01"
itxn_field ApprovalProgram
pushbytes "\x06\x81\x01"
itxn_field ClearStateProgram
pushint 0
itxn_field Fee
itxn_submit
// return
retsub

