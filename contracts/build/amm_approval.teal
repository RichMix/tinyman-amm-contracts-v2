#pragma version 7




// if Txn.ApplicationID == 0:
  txn ApplicationID
  pushint 0
  ==
  bz l0_end
  // then:
    // create app
    // app_global_put("fee_setter", Txn.Sender)
    pushbytes "fee_setter"
    txn Sender
    app_global_put
    // app_global_put("fee_collector", Txn.Sender)
    pushbytes "fee_collector"
    txn Sender
    app_global_put
    // app_global_put("fee_manager", Txn.Sender)
    pushbytes "fee_manager"
    txn Sender
    app_global_put
    // exit(1)
    pushint 1
    return
  l0_end: // end

// switch Txn.OnCompletion:
txn OnCompletion
pushint 0 // NoOp
==
bnz main
txn OnCompletion
pushint 1 // OptIn
==
bnz bootstrap
txn OnCompletion
pushint 2 // CloseOut
==
bnz handle_closeout
txn OnCompletion
pushint 4 // UpdateApplication
==
bnz handle_updateapp
txn OnCompletion
pushint 5 // DeleteApplication
==
bnz handle_deleteapp
err // unexpected value

// exit(0)
pushint 0
return

// block handle_updateapp
handle_updateapp:
  // exit(0)
  pushint 0
  return

// block handle_deleteapp
handle_deleteapp:
  // exit(0)
  pushint 0
  return

// block handle_closeout
handle_closeout:
  // exit(0)
  pushint 0
  return


// block bootstrap
bootstrap:
  // Gtxn[0]: Pay Algo to Pool Address from User
  // Gtxn[1]: AppCall with Optin from Pool Address to Bootstrap pool & ReKey to Application
  
  // itxn[0]: Pay Algo from Pool to Application
  // itxn[1]: Create Pool Token Asset from Application
  // itxn[2]: Optin Pool to Asset 1
  // itxn[3]: Optin Pool to Asset 2
  // itxn[4]: Optin Pool to Pool Token Asset
  // itxn[5]: Transfer Pool Token total supply to Pool Account
  
  // Should fail if:
  // Pool Address (Sender) != SHA512_256("program" + bytes from template and args)
  // Address already opted in to app
  
  // assert(Txn.ApplicationArgs[0] == "bootstrap")
  txna ApplicationArgs 0
  pushbytes "bootstrap"
  ==
  assert
  
  // Ensure the same asset ids are included in Txn.ApplicationArgs and Txn.Assets
  // int asset_1_id = btoi(Txn.ApplicationArgs[1]) [slot 0]
  txna ApplicationArgs 1
  btoi
  store 0 // asset_1_id
  // int asset_2_id = btoi(Txn.ApplicationArgs[2]) [slot 1]
  txna ApplicationArgs 2
  btoi
  store 1 // asset_2_id
  // int proxy_app_id = 0 [slot 2]
  pushint 0
  store 2 // proxy_app_id
  // assert(asset_1_id > asset_2_id)
  load 0 // asset_1_id
  load 1 // asset_2_id
  >
  assert
  // assert(asset_1_id == Txn.Assets[0])
  load 0 // asset_1_id
  txna Assets 0
  ==
  assert
  
  // int exists [slot 3]
  // byte asset_1_unit_name = "" [slot 4]
  pushbytes ""
  store 4 // asset_1_unit_name
  // byte asset_2_unit_name = "ALGO" [slot 5]
  pushbytes "ALGO"
  store 5 // asset_2_unit_name
  // int asset_total [slot 6]
  
  // exists, asset_1_unit_name = asset_params_get(AssetUnitName, asset_1_id)
  load 0 // asset_1_id
  asset_params_get AssetUnitName
  store 3 // exists
  store 4 // asset_1_unit_name
  // assert(exists)
  load 3 // exists
  assert
  
  // Ensure Asset 1 has total supply >= ASSET_MIN_TOTAL
  // exists, asset_total = asset_params_get(AssetTotal, asset_1_id)
  load 0 // asset_1_id
  asset_params_get AssetTotal
  store 3 // exists
  store 6 // asset_total
  // assert(exists && (asset_total >= ASSET_MIN_TOTAL))
  load 3 // exists
  load 6 // asset_total
  pushint 10000 // ASSET_MIN_TOTAL
  >=
  &&
  assert
  
  
  // if asset_2_id == 0:
    load 1 // asset_2_id
    pushint 0
    ==
    bz l1_else
    // then:
      // Asset 2 is Algo
      // assert(1 == Txn.NumAssets)
      pushint 1
      txn NumAssets
      ==
      assert
    b l1_end
    l1_else:
    // else:
      // assert(asset_2_id == Txn.Assets[1])
      load 1 // asset_2_id
      txna Assets 1
      ==
      assert
      // exists, asset_2_unit_name = asset_params_get(AssetUnitName, asset_2_id)
      load 1 // asset_2_id
      asset_params_get AssetUnitName
      store 3 // exists
      store 5 // asset_2_unit_name
      // assert(exists)
      load 3 // exists
      assert
      // Ensure Asset 2 has total supply >= ASSET_MIN_TOTAL
      // exists, asset_total = asset_params_get(AssetTotal, asset_2_id)
      load 1 // asset_2_id
      asset_params_get AssetTotal
      store 3 // exists
      store 6 // asset_total
      // assert(exists && (asset_total >= ASSET_MIN_TOTAL))
      load 3 // exists
      load 6 // asset_total
      pushint 10000 // ASSET_MIN_TOTAL
      >=
      &&
      assert
    l1_end: // end
  
  // byte pool_token_asset_name = concat("TinymanPool2.0 ", concat(concat(asset_1_unit_name, "-"), asset_2_unit_name)) [slot 7]
  pushbytes "TinymanPool2.0 "
  load 4 // asset_1_unit_name
  pushbytes "-"
  concat
  load 5 // asset_2_unit_name
  concat
  concat
  store 7 // pool_token_asset_name
  
  // byte pool_address = Txn.Sender [slot 8]
  txn Sender
  store 8 // pool_address
  
  // Ensure pool_address == SHA512_256("program" + bytes from template and args)
  // byte program = replace2(3, TEMPLATE, itob(Global.CurrentApplicationID)) [slot 9]
  pushbytes "\x06\x80 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x81\x00[5\x004\x001\x18\x12D1\x19\x81\x01\x12D\x81\x01C" // TEMPLATE
  global CurrentApplicationID
  itob
  replace2 3
  store 9 // program
  // program = replace2(11, program, Txn.ApplicationArgs[1])
  load 9 // program
  txna ApplicationArgs 1
  replace2 11
  store 9 // program
  // program = replace2(19, program, Txn.ApplicationArgs[2])
  load 9 // program
  txna ApplicationArgs 2
  replace2 19
  store 9 // program
  // if Txn.NumAppArgs > 3:
    txn NumAppArgs
    pushint 3
    >
    bz l2_end
    // then:
      // proxy_app_id = btoi(Txn.ApplicationArgs[3])
      txna ApplicationArgs 3
      btoi
      store 2 // proxy_app_id
      // program = replace2(27, program, Txn.ApplicationArgs[3])
      load 9 // program
      txna ApplicationArgs 3
      replace2 27
      store 9 // program
    l2_end: // end
  // byte hash = sha512_256(concat("Program", program)) [slot 10]
  pushbytes "Program"
  load 9 // program
  concat
  sha512_256
  store 10 // hash
  // assert(hash == pool_address)
  load 10 // hash
  load 8 // pool_address
  ==
  assert
  
  // Ensure Txn includes rekey to application address
  // assert(Txn.RekeyTo == Global.CurrentApplicationAddress)
  txn RekeyTo
  global CurrentApplicationAddress
  ==
  assert
  
  // NOTE: Fee should be set to 0 for all inner transactions to ensure it is paid by an outer transaction sender instead of the Pool.
  // No need for further fee checks.
  
  // itxn[0]: Pay Algo from Pool to Application to fund Asset Creation
  // 
  itxn_begin
  // inner_txn:
  pushint 1 // Pay
  itxn_field TypeEnum
  load 8 // pool_address
  itxn_field Sender
  global CurrentApplicationAddress
  itxn_field Receiver
  pushint 200000
  itxn_field Amount
  pushint 0
  itxn_field Fee
  itxn_submit
  
  // itxn[1]: Create Pool Token Asset from Application Address
  // 
  itxn_begin
  // inner_txn:
  pushint 3 // Acfg
  itxn_field TypeEnum
  global CurrentApplicationAddress
  itxn_field Sender
  pushbytes "TMPOOL2"
  itxn_field ConfigAssetUnitName
  load 7 // pool_token_asset_name
  itxn_field ConfigAssetName
  pushint 18446744073709551615 // POOL_TOKEN_TOTAL_SUPPLY
  itxn_field ConfigAssetTotal
  pushint 6
  itxn_field ConfigAssetDecimals
  pushbytes "https://tinyman.org"
  itxn_field ConfigAssetURL
  pushint 0
  itxn_field Fee
  itxn_submit
  
  // Get the id of the asset just created
  // int pool_token_asset_id = Itxn.CreatedAssetID [slot 11]
  itxn CreatedAssetID
  store 11 // pool_token_asset_id
  
  // itxn[2]: Optin Pool to Asset 1
  // 
  itxn_begin
  // inner_txn:
  pushint 4 // Axfer
  itxn_field TypeEnum
  load 8 // pool_address
  itxn_field Sender
  load 8 // pool_address
  itxn_field AssetReceiver
  load 0 // asset_1_id
  itxn_field XferAsset
  pushint 0
  itxn_field Amount
  pushint 0
  itxn_field Fee
  itxn_submit
  
  // itxn[3]: Optin Pool to Asset 2
  // if asset_2_id > 0:
    load 1 // asset_2_id
    pushint 0
    >
    bz l3_end
    // then:
      // 
      itxn_begin
      // inner_txn:
      pushint 4 // Axfer
      itxn_field TypeEnum
      load 8 // pool_address
      itxn_field Sender
      load 8 // pool_address
      itxn_field AssetReceiver
      load 1 // asset_2_id
      itxn_field XferAsset
      pushint 0
      itxn_field Amount
      pushint 0
      itxn_field Fee
      itxn_submit
    l3_end: // end
  
  // itxn[4]: Optin Pool to Pool Token Asset
  // 
  itxn_begin
  // inner_txn:
  pushint 4 // Axfer
  itxn_field TypeEnum
  load 8 // pool_address
  itxn_field Sender
  load 8 // pool_address
  itxn_field AssetReceiver
  load 11 // pool_token_asset_id
  itxn_field XferAsset
  pushint 0
  itxn_field Amount
  pushint 0
  itxn_field Fee
  itxn_submit
  
  // itxn[5]: Transfer Pool Token total supply to Pool Account
  // 
  itxn_begin
  // inner_txn:
  pushint 4 // Axfer
  itxn_field TypeEnum
  global CurrentApplicationAddress
  itxn_field Sender
  load 8 // pool_address
  itxn_field AssetReceiver
  load 11 // pool_token_asset_id
  itxn_field XferAsset
  pushint 18446744073709551615 // POOL_TOKEN_TOTAL_SUPPLY
  itxn_field AssetAmount
  pushint 0
  itxn_field Fee
  itxn_submit
  
  // int poolers_fee_share = 25 [slot 12]
  pushint 25
  store 12 // poolers_fee_share
  // int protocol_fee_share = 5 [slot 13]
  pushint 5
  store 13 // protocol_fee_share
  // State updates
  // [pool_token_asset_id]
  // [asset_1]
  // [asset_2]
  // [poolers_fee_share]
  // [protocol_fee_share]
  // app_local_put(0, "pool_token_asset_id", pool_token_asset_id)
  pushint 0
  pushbytes "pool_token_asset_id"
  load 11 // pool_token_asset_id
  app_local_put
  // app_local_put(0, "asset_1_id", asset_1_id)
  pushint 0
  pushbytes "asset_1_id"
  load 0 // asset_1_id
  app_local_put
  // app_local_put(0, "asset_2_id", asset_2_id)
  pushint 0
  pushbytes "asset_2_id"
  load 1 // asset_2_id
  app_local_put
  // app_local_put(0, "poolers_fee_share", poolers_fee_share)
  pushint 0
  pushbytes "poolers_fee_share"
  load 12 // poolers_fee_share
  app_local_put
  // app_local_put(0, "protocol_fee_share", protocol_fee_share)
  pushint 0
  pushbytes "protocol_fee_share"
  load 13 // protocol_fee_share
  app_local_put
  // app_local_put(0, "proxy_app_id", proxy_app_id)
  pushint 0
  pushbytes "proxy_app_id"
  load 2 // proxy_app_id
  app_local_put
  // Set all remaining keys with initials values
  // app_local_put(0, "asset_1_reserves", 0)
  pushint 0
  pushbytes "asset_1_reserves"
  pushint 0
  app_local_put
  // app_local_put(0, "asset_2_reserves", 0)
  pushint 0
  pushbytes "asset_2_reserves"
  pushint 0
  app_local_put
  // app_local_put(0, "issued_pool_tokens", 0)
  pushint 0
  pushbytes "issued_pool_tokens"
  pushint 0
  app_local_put
  // app_local_put(0, "protocol_fees_asset_1", 0)
  pushint 0
  pushbytes "protocol_fees_asset_1"
  pushint 0
  app_local_put
  // app_local_put(0, "protocol_fees_asset_2", 0)
  pushint 0
  pushbytes "protocol_fees_asset_2"
  pushint 0
  app_local_put
  // app_local_put(0, "cumulative_asset_1_price", BYTE_ZERO)
  pushint 0
  pushbytes "cumulative_asset_1_price"
  pushbytes "\x00\x00\x00\x00\x00\x00\x00\x00" // BYTE_ZERO
  app_local_put
  // app_local_put(0, "cumulative_asset_2_price", BYTE_ZERO)
  pushint 0
  pushbytes "cumulative_asset_2_price"
  pushbytes "\x00\x00\x00\x00\x00\x00\x00\x00" // BYTE_ZERO
  app_local_put
  // app_local_put(0, "cumulative_price_update_timestamp", Global.LatestTimestamp)
  pushint 0
  pushbytes "cumulative_price_update_timestamp"
  global LatestTimestamp
  app_local_put
  // exit(1)
  pushint 1
  return


// block main
main:
  // Protect the user from malicious clients that might hide a rekey in a swap call
  // assert(Txn.RekeyTo == Global.ZeroAddress)
  txn RekeyTo
  global ZeroAddress
  ==
  assert
  
  // byte user_address = Txn.Sender [slot 0]
  txn Sender
  store 0 // user_address
  // switch Txn.ApplicationArgs[0]:
  txna ApplicationArgs 0
  pushbytes "set_fee_collector"
  ==
  bnz main__set_fee_collector
  txna ApplicationArgs 0
  pushbytes "set_fee_setter"
  ==
  bnz main__set_fee_setter
  txna ApplicationArgs 0
  pushbytes "set_fee_manager"
  ==
  bnz main__set_fee_manager
  txna ApplicationArgs 0
  pushbytes "claim_fees"
  ==
  bnz main__claim_fees
  txna ApplicationArgs 0
  pushbytes "claim_extra"
  ==
  bnz main__claim_extra
  txna ApplicationArgs 0
  pushbytes "set_fee"
  ==
  bnz main__set_fee
  b main__amm // else
  
  // block set_fee_collector
  main__set_fee_collector:
    // Set a new fee collector, only fee manager can call this method
    // Txn: AppCall from fee_manager
    
    // assert(user_address == app_global_get("fee_manager"))
    load 0 // user_address
    pushbytes "fee_manager"
    app_global_get
    ==
    assert
    
    // State updates
    // [fee_collector]
    // app_global_put("fee_collector", Txn.Accounts[1])
    pushbytes "fee_collector"
    txna Accounts 1
    app_global_put
    // exit(1)
    pushint 1
    return
  
  // block set_fee_setter
  main__set_fee_setter:
    // Set a new fee setter, only fee manager can call this method
    // Txn: AppCall from fee_manager
    
    // assert(user_address == app_global_get("fee_manager"))
    load 0 // user_address
    pushbytes "fee_manager"
    app_global_get
    ==
    assert
    
    // State updates
    // [fee_setter]
    // app_global_put("fee_setter", Txn.Accounts[1])
    pushbytes "fee_setter"
    txna Accounts 1
    app_global_put
    // exit(1)
    pushint 1
    return
  
  // block set_fee_manager
  main__set_fee_manager:
    // Set a new fee manager, only fee manager can call this method
    // Txn: AppCall from fee_manager
    
    // assert(user_address == app_global_get("fee_manager"))
    load 0 // user_address
    pushbytes "fee_manager"
    app_global_get
    ==
    assert
    
    // State updates
    // [fee_manager]
    // app_global_put("fee_manager", Txn.Accounts[1])
    pushbytes "fee_manager"
    txna Accounts 1
    app_global_put
    // exit(1)
    pushint 1
    return
  
  // block claim_fees
  main__claim_fees:
    // Transfer accumulated fees from the pool to the fee_collector
    
    // Gtxn[0]: AppCall from User
    
    // itxn[0]: Transfer Asset 1 to fee_collector from Pool
    // itxn[1]: Transfer Asset 2 to fee_collector from Pool
    
    // byte pool_address = Txn.Accounts[1] [slot 1]
    txna Accounts 1
    store 1 // pool_address
    // int asset_1_id = app_local_get(1, "asset_1_id") [slot 2]
    pushint 1
    pushbytes "asset_1_id"
    app_local_get
    store 2 // asset_1_id
    // int asset_2_id = app_local_get(1, "asset_2_id") [slot 3]
    pushint 1
    pushbytes "asset_2_id"
    app_local_get
    store 3 // asset_2_id
    // int protocol_fees_asset_1 = app_local_get(1, "protocol_fees_asset_1") [slot 4]
    pushint 1
    pushbytes "protocol_fees_asset_1"
    app_local_get
    store 4 // protocol_fees_asset_1
    // int protocol_fees_asset_2 = app_local_get(1, "protocol_fees_asset_2") [slot 5]
    pushint 1
    pushbytes "protocol_fees_asset_2"
    app_local_get
    store 5 // protocol_fees_asset_2
    
    // assert(protocol_fees_asset_1 || protocol_fees_asset_2)
    load 4 // protocol_fees_asset_1
    load 5 // protocol_fees_asset_2
    ||
    assert
    // transfer(asset_1_id, protocol_fees_asset_1, pool_address, app_global_get("fee_collector"))
    load 2 // asset_1_id
    load 4 // protocol_fees_asset_1
    load 1 // pool_address
    pushbytes "fee_collector"
    app_global_get
    callsub __func__transfer
    // transfer(asset_2_id, protocol_fees_asset_2, pool_address, app_global_get("fee_collector"))
    load 3 // asset_2_id
    load 5 // protocol_fees_asset_2
    load 1 // pool_address
    pushbytes "fee_collector"
    app_global_get
    callsub __func__transfer
    
    // State updates
    // app_local_put(1, "protocol_fees_asset_1", 0)
    pushint 1
    pushbytes "protocol_fees_asset_1"
    pushint 0
    app_local_put
    // app_local_put(1, "protocol_fees_asset_2", 0)
    pushint 1
    pushbytes "protocol_fees_asset_2"
    pushint 0
    app_local_put
    // exit(1)
    pushint 1
    return
  
  // block claim_extra
  main__claim_extra:
    // Transfer any extra donations to the fee_collector
    
    // Gtxn[0]: AppCall from User
    // Note: must account for min balance when asset_2 is algo
    
    // itxn[0]: Transfer Asset 1 to fee_collector from Pool
    // itxn[1]: Transfer Asset 2 to fee_collector from Pool
    
    // byte pool_address = Txn.Accounts[1] [slot 1]
    txna Accounts 1
    store 1 // pool_address
    // int asset_1_id = app_local_get(1, "asset_1_id") [slot 2]
    pushint 1
    pushbytes "asset_1_id"
    app_local_get
    store 2 // asset_1_id
    // int asset_2_id = app_local_get(1, "asset_2_id") [slot 3]
    pushint 1
    pushbytes "asset_2_id"
    app_local_get
    store 3 // asset_2_id
    
    // int asset_1_amount = get_balance(1, asset_1_id) - (app_local_get(1, "asset_1_reserves") + app_local_get(1, "protocol_fees_asset_1")) [slot 4]
    pushint 1
    load 2 // asset_1_id
    callsub __func__get_balance
    pushint 1
    pushbytes "asset_1_reserves"
    app_local_get
    pushint 1
    pushbytes "protocol_fees_asset_1"
    app_local_get
    +
    -
    store 4 // asset_1_amount
    // int asset_2_amount = get_balance(1, asset_2_id) - (app_local_get(1, "asset_2_reserves") + app_local_get(1, "protocol_fees_asset_2")) [slot 5]
    pushint 1
    load 3 // asset_2_id
    callsub __func__get_balance
    pushint 1
    pushbytes "asset_2_reserves"
    app_local_get
    pushint 1
    pushbytes "protocol_fees_asset_2"
    app_local_get
    +
    -
    store 5 // asset_2_amount
    
    // assert(asset_1_amount || asset_2_amount)
    load 4 // asset_1_amount
    load 5 // asset_2_amount
    ||
    assert
    // transfer(asset_1_id, asset_1_amount, pool_address, app_global_get("fee_collector"))
    load 2 // asset_1_id
    load 4 // asset_1_amount
    load 1 // pool_address
    pushbytes "fee_collector"
    app_global_get
    callsub __func__transfer
    // transfer(asset_2_id, asset_2_amount, pool_address, app_global_get("fee_collector"))
    load 3 // asset_2_id
    load 5 // asset_2_amount
    load 1 // pool_address
    pushbytes "fee_collector"
    app_global_get
    callsub __func__transfer
    // exit(1)
    pushint 1
    return
  
  // block set_fee
  main__set_fee:
    // Set a new fee collector, only fee setter can call this method
    // Txn: AppCall from fee_setter
    // assert(user_address == app_global_get("fee_setter"))
    load 0 // user_address
    pushbytes "fee_setter"
    app_global_get
    ==
    assert
    
    // int poolers_fee_share = btoi(Txn.ApplicationArgs[1]) [slot 1]
    txna ApplicationArgs 1
    btoi
    store 1 // poolers_fee_share
    // int protocol_fee_share = btoi(Txn.ApplicationArgs[2]) [slot 2]
    txna ApplicationArgs 2
    btoi
    store 2 // protocol_fee_share
    
    // TODO: Dummy validation for now
    // assert(poolers_fee_share <= 50)
    load 1 // poolers_fee_share
    pushint 50
    <=
    assert
    // assert(protocol_fee_share <= 10)
    load 2 // protocol_fee_share
    pushint 10
    <=
    assert
    // assert(poolers_fee_share >= protocol_fee_share)
    load 1 // poolers_fee_share
    load 2 // protocol_fee_share
    >=
    assert
    // assert(poolers_fee_share >= (protocol_fee_share * 5))
    load 1 // poolers_fee_share
    load 2 // protocol_fee_share
    pushint 5
    *
    >=
    assert
    
    // State updates
    // [poolers_fee_share]
    // [protocol_fee_share]
    // app_local_put(1, "poolers_fee_share", poolers_fee_share)
    pushint 1
    pushbytes "poolers_fee_share"
    load 1 // poolers_fee_share
    app_local_put
    // app_local_put(1, "protocol_fee_share", protocol_fee_share)
    pushint 1
    pushbytes "protocol_fee_share"
    load 2 // protocol_fee_share
    app_local_put
    // exit(1)
    pushint 1
    return
  
  // block amm
  main__amm:
    // byte pool_address = Txn.Accounts[1] [slot 1]
    txna Accounts 1
    store 1 // pool_address
    // These will fail if the account is not optted-in and only pool accounts can opt-in to the app.
    // int asset_1_id = app_local_get(1, "asset_1_id") [slot 2]
    pushint 1
    pushbytes "asset_1_id"
    app_local_get
    store 2 // asset_1_id
    // int asset_2_id = app_local_get(1, "asset_2_id") [slot 3]
    pushint 1
    pushbytes "asset_2_id"
    app_local_get
    store 3 // asset_2_id
    // int pool_token_asset_id = app_local_get(1, "pool_token_asset_id") [slot 4]
    pushint 1
    pushbytes "pool_token_asset_id"
    app_local_get
    store 4 // pool_token_asset_id
    // int asset_1_reserves = app_local_get(1, "asset_1_reserves") [slot 5]
    pushint 1
    pushbytes "asset_1_reserves"
    app_local_get
    store 5 // asset_1_reserves
    // int asset_2_reserves = app_local_get(1, "asset_2_reserves") [slot 6]
    pushint 1
    pushbytes "asset_2_reserves"
    app_local_get
    store 6 // asset_2_reserves
    // int issued_pool_tokens = app_local_get(1, "issued_pool_tokens") [slot 7]
    pushint 1
    pushbytes "issued_pool_tokens"
    app_local_get
    store 7 // issued_pool_tokens
    // int protocol_fees_asset_1 = app_local_get(1, "protocol_fees_asset_1") [slot 8]
    pushint 1
    pushbytes "protocol_fees_asset_1"
    app_local_get
    store 8 // protocol_fees_asset_1
    // int protocol_fees_asset_2 = app_local_get(1, "protocol_fees_asset_2") [slot 9]
    pushint 1
    pushbytes "protocol_fees_asset_2"
    app_local_get
    store 9 // protocol_fees_asset_2
    // int proxy_app_id = app_local_get(1, "proxy_app_id") [slot 10]
    pushint 1
    pushbytes "proxy_app_id"
    app_local_get
    store 10 // proxy_app_id
    
    // if proxy_app_id:
      load 10 // proxy_app_id
      bz l4_end
      // then:
        // assert(Global.CallerApplicationID == proxy_app_id)
        global CallerApplicationID
        load 10 // proxy_app_id
        ==
        assert
      l4_end: // end
    
    // assert((Txn.ApplicationArgs[0] == "verify_flash_swap") || (app_local_get(1, "lock") == 0))
    txna ApplicationArgs 0
    pushbytes "verify_flash_swap"
    ==
    pushint 1
    pushbytes "lock"
    app_local_get
    pushint 0
    ==
    ||
    assert
    
    // switch Txn.ApplicationArgs[0]:
    txna ApplicationArgs 0
    pushbytes "add_liquidity"
    ==
    bnz main__amm__add_liquidity
    txna ApplicationArgs 0
    pushbytes "remove_liquidity"
    ==
    bnz main__amm__remove_liquidity
    txna ApplicationArgs 0
    pushbytes "swap"
    ==
    bnz main__amm__swap
    txna ApplicationArgs 0
    pushbytes "flash_loan"
    ==
    bnz main__amm__flash_loan
    txna ApplicationArgs 0
    pushbytes "verify_flash_loan"
    ==
    bnz main__amm__verify_flash_loan
    txna ApplicationArgs 0
    pushbytes "flash_swap"
    ==
    bnz main__amm__flash_swap
    txna ApplicationArgs 0
    pushbytes "verify_flash_swap"
    ==
    bnz main__amm__verify_flash_swap
    err // unexpected value
    
    
    // block swap
    main__amm__swap:
      // update_price_oracle()
      callsub main__amm__func__update_price_oracle
      // Gtxn[0]: Transfer Asset1 to Pool from User
      // Gtxn[1]: AppCall from User
      
      // itxn[0]: Transfer Asset 2 to User from Pool
      
      // byte k_initial = itob(asset_1_reserves) b* itob(asset_2_reserves) [slot 11]
      load 5 // asset_1_reserves
      itob
      load 6 // asset_2_reserves
      itob
      b*
      store 11 // k_initial
      // int input_asset_id = btoi(Txn.ApplicationArgs[1]) [slot 12]
      txna ApplicationArgs 1
      btoi
      store 12 // input_asset_id
      // int output_asset_id = btoi(Txn.ApplicationArgs[2]) [slot 13]
      txna ApplicationArgs 2
      btoi
      store 13 // output_asset_id
      // int min_output = btoi(Txn.ApplicationArgs[3]) [slot 14]
      txna ApplicationArgs 3
      btoi
      store 14 // min_output
      // int mode = Txn.ApplicationArgs[4] [slot 15]
      txna ApplicationArgs 4
      store 15 // mode
      
      // int input_amount [slot 16]
      // int input_txn_index = Txn.GroupIndex - 1 [slot 17]
      txn GroupIndex
      pushint 1
      -
      store 17 // input_txn_index
      // if input_asset_id == 0:
        load 12 // input_asset_id
        pushint 0
        ==
        bz l5_else
        // then:
          // assert(Gtxn[input_txn_index].TypeEnum == Pay)
          load 17 // input_txn_index
          gtxns TypeEnum
          pushint 1 // Pay
          ==
          assert
          // assert(Gtxn[input_txn_index].Receiver == pool_address)
          load 17 // input_txn_index
          gtxns Receiver
          load 1 // pool_address
          ==
          assert
          // input_amount = Gtxn[input_txn_index].Amount
          load 17 // input_txn_index
          gtxns Amount
          store 16 // input_amount
        b l5_end
        l5_else:
        // else:
          // assert(Gtxn[input_txn_index].TypeEnum == Axfer)
          load 17 // input_txn_index
          gtxns TypeEnum
          pushint 4 // Axfer
          ==
          assert
          // assert(Gtxn[input_txn_index].AssetReceiver == pool_address)
          load 17 // input_txn_index
          gtxns AssetReceiver
          load 1 // pool_address
          ==
          assert
          // assert(Gtxn[input_txn_index].XferAsset == input_asset_id)
          load 17 // input_txn_index
          gtxns XferAsset
          load 12 // input_asset_id
          ==
          assert
          // input_amount = Gtxn[input_txn_index].AssetAmount
          load 17 // input_txn_index
          gtxns AssetAmount
          store 16 // input_amount
        l5_end: // end
      
      // input_asset_id must be asset_1_id or asset_2_id
      // output_asset_id must be asset_1_id or asset_2_id
      // input_asset_id must not equal output_asset_id
      // int input_supply [slot 18]
      // int output_supply [slot 19]
      // if (input_asset_id == asset_1_id) && (output_asset_id == asset_2_id):
        load 12 // input_asset_id
        load 2 // asset_1_id
        ==
        load 13 // output_asset_id
        load 3 // asset_2_id
        ==
        &&
        bz l6_elif_0
        // then:
          // input_supply = asset_1_reserves
          load 5 // asset_1_reserves
          store 18 // input_supply
          // output_supply = asset_2_reserves
          load 6 // asset_2_reserves
          store 19 // output_supply
        b l6_end
        l6_elif_0:
        // elif (input_asset_id == asset_2_id) && (output_asset_id == asset_1_id):
        load 12 // input_asset_id
        load 3 // asset_2_id
        ==
        load 13 // output_asset_id
        load 2 // asset_1_id
        ==
        &&
        bz l6_else
          // input_supply = asset_2_reserves
          load 6 // asset_2_reserves
          store 18 // input_supply
          // output_supply = asset_1_reserves
          load 5 // asset_1_reserves
          store 19 // output_supply
        b l6_end
        l6_else:
        // else:
          // error()
          err
        l6_end: // end
      
      // int total_fee_amount [slot 20]
      // int poolers_fee_amount [slot 21]
      // int protocol_fee_amount [slot 22]
      // int swap_amount [slot 23]
      // int output_amount [slot 24]
      // int change = 0 [slot 25]
      pushint 0
      store 25 // change
      // if mode == 'fixed-input':
        load 15 // mode
        pushbytes "fixed-input"
        ==
        bz l7_elif_0
        // then:
          // total_fee_amount, poolers_fee_amount, protocol_fee_amount = calculate_fixed_input_fee_amounts(input_amount)
          load 16 // input_amount
          callsub __func__calculate_fixed_input_fee_amounts
          store 20 // total_fee_amount
          store 21 // poolers_fee_amount
          store 22 // protocol_fee_amount
          // swap_amount = input_amount - total_fee_amount
          load 16 // input_amount
          load 20 // total_fee_amount
          -
          store 23 // swap_amount
          // output_amount = calculate_fixed_input_swap(input_supply, output_supply, swap_amount)
          load 18 // input_supply
          load 19 // output_supply
          load 23 // swap_amount
          callsub __func__calculate_fixed_input_swap
          store 24 // output_amount
          
          // assert(total_fee_amount, "If the amount is too small, total fee amount is rounded to 0.")
          load 20 // total_fee_amount
          assert // If the amount is too small, total fee amount is rounded to 0.
          // assert(output_amount >= min_output)
          load 24 // output_amount
          load 14 // min_output
          >=
          assert
        b l7_end
        l7_elif_0:
        // elif mode == 'fixed-output':
        load 15 // mode
        pushbytes "fixed-output"
        ==
        bz l7_else
          // output_amount = min_output
          load 14 // min_output
          store 24 // output_amount
          // swap_amount = calculate_fixed_output_swap(input_supply, output_supply, output_amount)
          load 18 // input_supply
          load 19 // output_supply
          load 24 // output_amount
          callsub __func__calculate_fixed_output_swap
          store 23 // swap_amount
          // total_fee_amount, poolers_fee_amount, protocol_fee_amount = calculate_fixed_output_fee_amounts(swap_amount)
          load 23 // swap_amount
          callsub __func__calculate_fixed_output_fee_amounts
          store 20 // total_fee_amount
          store 21 // poolers_fee_amount
          store 22 // protocol_fee_amount
          // int total_input_amount = swap_amount + total_fee_amount [slot 26]
          load 23 // swap_amount
          load 20 // total_fee_amount
          +
          store 26 // total_input_amount
          
          // assert(total_fee_amount, "If the amount is too small, total fee amount is rounded to 0.")
          load 20 // total_fee_amount
          assert // If the amount is too small, total fee amount is rounded to 0.
          // assert(input_amount >= total_input_amount)
          load 16 // input_amount
          load 26 // total_input_amount
          >=
          assert
          
          // change = input_amount - total_input_amount
          load 16 // input_amount
          load 26 // total_input_amount
          -
          store 25 // change
          // if change:
            load 25 // change
            bz l8_end
            // then:
              // transfer_to_user(input_asset_id, change)
              load 12 // input_asset_id
              load 25 // change
              callsub main__amm__func__transfer_to_user
            l8_end: // end
        b l7_end
        l7_else:
        // else:
          // error()
          err
        l7_end: // end
      
      // log(concat("input_amount %i", itob(input_amount)))
      pushbytes "input_amount %i"
      load 16 // input_amount
      itob
      concat
      log
      // log(concat("poolers_fee_amount %i", itob(poolers_fee_amount)))
      pushbytes "poolers_fee_amount %i"
      load 21 // poolers_fee_amount
      itob
      concat
      log
      // log(concat("protocol_fee_amount %i", itob(protocol_fee_amount)))
      pushbytes "protocol_fee_amount %i"
      load 22 // protocol_fee_amount
      itob
      concat
      log
      // log(concat("swap_amount %i", itob(swap_amount)))
      pushbytes "swap_amount %i"
      load 23 // swap_amount
      itob
      concat
      log
      // log(concat("output_amount %i", itob(output_amount)))
      pushbytes "output_amount %i"
      load 24 // output_amount
      itob
      concat
      log
      // log(concat("change %i", itob(change)))
      pushbytes "change %i"
      load 25 // change
      itob
      concat
      log
      
      // if input_asset_id == asset_1_id:
        load 12 // input_asset_id
        load 2 // asset_1_id
        ==
        bz l9_else
        // then:
          // protocol_fees_asset_1 = protocol_fees_asset_1 + protocol_fee_amount
          load 8 // protocol_fees_asset_1
          load 22 // protocol_fee_amount
          +
          store 8 // protocol_fees_asset_1
          // asset_1_reserves = asset_1_reserves + (swap_amount + poolers_fee_amount)
          load 5 // asset_1_reserves
          load 23 // swap_amount
          load 21 // poolers_fee_amount
          +
          +
          store 5 // asset_1_reserves
          // asset_2_reserves = asset_2_reserves - output_amount
          load 6 // asset_2_reserves
          load 24 // output_amount
          -
          store 6 // asset_2_reserves
        b l9_end
        l9_else:
        // else:
          // protocol_fees_asset_2 = protocol_fees_asset_2 + protocol_fee_amount
          load 9 // protocol_fees_asset_2
          load 22 // protocol_fee_amount
          +
          store 9 // protocol_fees_asset_2
          // asset_2_reserves = asset_2_reserves + (swap_amount + poolers_fee_amount)
          load 6 // asset_2_reserves
          load 23 // swap_amount
          load 21 // poolers_fee_amount
          +
          +
          store 6 // asset_2_reserves
          // asset_1_reserves = asset_1_reserves - output_amount
          load 5 // asset_1_reserves
          load 24 // output_amount
          -
          store 5 // asset_1_reserves
        l9_end: // end
      
      // transfer_to_user(output_asset_id, output_amount)
      load 13 // output_asset_id
      load 24 // output_amount
      callsub main__amm__func__transfer_to_user
      
      // assert(k_initial b< (itob(asset_1_reserves) b* itob(asset_2_reserves)), "Assert K<K'")
      load 11 // k_initial
      load 5 // asset_1_reserves
      itob
      load 6 // asset_2_reserves
      itob
      b*
      b<
      assert // Assert K<K'
      // State updates
      // app_local_put(1, "asset_1_reserves", asset_1_reserves)
      pushint 1
      pushbytes "asset_1_reserves"
      load 5 // asset_1_reserves
      app_local_put
      // app_local_put(1, "asset_2_reserves", asset_2_reserves)
      pushint 1
      pushbytes "asset_2_reserves"
      load 6 // asset_2_reserves
      app_local_put
      // app_local_put(1, "protocol_fees_asset_1", protocol_fees_asset_1)
      pushint 1
      pushbytes "protocol_fees_asset_1"
      load 8 // protocol_fees_asset_1
      app_local_put
      // app_local_put(1, "protocol_fees_asset_2", protocol_fees_asset_2)
      pushint 1
      pushbytes "protocol_fees_asset_2"
      load 9 // protocol_fees_asset_2
      app_local_put
      // exit(1)
      pushint 1
      return
    
    // block flash_loan
    main__amm__flash_loan:
      // update_price_oracle()
      callsub main__amm__func__update_price_oracle
      // Gtxn[X]: Flash Loan AppCall from User
      // itxn: Transfer Asset 1 to User from Pool if Asset 1 is requested
      // itxn: Transfer Asset 2 to User from Pool if Asset 2 is requested
      
      // int index_diff = btoi(Txn.ApplicationArgs[1]) [slot 11]
      txna ApplicationArgs 1
      btoi
      store 11 // index_diff
      // int asset_1_amount = btoi(Txn.ApplicationArgs[2]) [slot 12]
      txna ApplicationArgs 2
      btoi
      store 12 // asset_1_amount
      // int asset_2_amount = btoi(Txn.ApplicationArgs[3]) [slot 13]
      txna ApplicationArgs 3
      btoi
      store 13 // asset_2_amount
      // assert(asset_1_amount || asset_2_amount)
      load 12 // asset_1_amount
      load 13 // asset_2_amount
      ||
      assert
      
      // int verify_flash_loan_txn_index = Txn.GroupIndex + index_diff [slot 14]
      txn GroupIndex
      load 11 // index_diff
      +
      store 14 // verify_flash_loan_txn_index
      // assert(Gtxn[verify_flash_loan_txn_index].Sender == Txn.Sender)
      load 14 // verify_flash_loan_txn_index
      gtxns Sender
      txn Sender
      ==
      assert
      // assert(Gtxn[verify_flash_loan_txn_index].TypeEnum == Appl)
      load 14 // verify_flash_loan_txn_index
      gtxns TypeEnum
      pushint 6 // Appl
      ==
      assert
      // assert(Gtxn[verify_flash_loan_txn_index].ApplicationID == Global.CurrentApplicationID)
      load 14 // verify_flash_loan_txn_index
      gtxns ApplicationID
      global CurrentApplicationID
      ==
      assert
      // assert(Gtxn[verify_flash_loan_txn_index].ApplicationArgs[0] == "verify_flash_loan")
      load 14 // verify_flash_loan_txn_index
      gtxnsa ApplicationArgs 0
      pushbytes "verify_flash_loan"
      ==
      assert
      // assert(Gtxn[verify_flash_loan_txn_index].ApplicationArgs[1] == Txn.ApplicationArgs[1], "index_diff")
      load 14 // verify_flash_loan_txn_index
      gtxnsa ApplicationArgs 1
      txna ApplicationArgs 1
      ==
      assert // index_diff
      
      // if asset_1_amount:
        load 12 // asset_1_amount
        bz l10_end
        // then:
          // assert(asset_1_amount <= asset_1_reserves)
          load 12 // asset_1_amount
          load 5 // asset_1_reserves
          <=
          assert
          // transfer_to_user(asset_1_id, asset_1_amount)
          load 2 // asset_1_id
          load 12 // asset_1_amount
          callsub main__amm__func__transfer_to_user
        l10_end: // end
      // if asset_2_amount:
        load 13 // asset_2_amount
        bz l11_end
        // then:
          // assert(asset_2_amount <= asset_2_reserves)
          load 13 // asset_2_amount
          load 6 // asset_2_reserves
          <=
          assert
          // transfer_to_user(asset_2_id, asset_2_amount)
          load 3 // asset_2_id
          load 13 // asset_2_amount
          callsub main__amm__func__transfer_to_user
        l11_end: // end
      // exit(1)
      pushint 1
      return
    
    // block verify_flash_loan
    main__amm__verify_flash_loan:
      // if borrowed in two assets:
      // Gtxn[X-2]: Transfer Asset 1 to Pool
      // Gtxn[X-1]: Transfer Asset 2 to Pool
      // if borrowed single asset:
      // Gtxn[X-1]: Transfer borrowed Asset to Pool
      
      // Gtxn[X]: Verify Flash Loan AppCall from User
      
      // int index_diff = btoi(Txn.ApplicationArgs[1]) [slot 11]
      txna ApplicationArgs 1
      btoi
      store 11 // index_diff
      // int flash_loan_txn_index = Txn.GroupIndex - index_diff [slot 12]
      txn GroupIndex
      load 11 // index_diff
      -
      store 12 // flash_loan_txn_index
      // assert(Gtxn[flash_loan_txn_index].TypeEnum == Appl)
      load 12 // flash_loan_txn_index
      gtxns TypeEnum
      pushint 6 // Appl
      ==
      assert
      // assert(Gtxn[flash_loan_txn_index].ApplicationID == Global.CurrentApplicationID)
      load 12 // flash_loan_txn_index
      gtxns ApplicationID
      global CurrentApplicationID
      ==
      assert
      // assert(Gtxn[flash_loan_txn_index].ApplicationArgs[0] == "flash_loan")
      load 12 // flash_loan_txn_index
      gtxnsa ApplicationArgs 0
      pushbytes "flash_loan"
      ==
      assert
      // assert(Gtxn[flash_loan_txn_index].ApplicationArgs[1] == Txn.ApplicationArgs[1], "index_diff")
      load 12 // flash_loan_txn_index
      gtxnsa ApplicationArgs 1
      txna ApplicationArgs 1
      ==
      assert // index_diff
      // int asset_1_amount = btoi(Gtxn[flash_loan_txn_index].ApplicationArgs[2]) [slot 13]
      load 12 // flash_loan_txn_index
      gtxnsa ApplicationArgs 2
      btoi
      store 13 // asset_1_amount
      // int asset_2_amount = btoi(Gtxn[flash_loan_txn_index].ApplicationArgs[3]) [slot 14]
      load 12 // flash_loan_txn_index
      gtxnsa ApplicationArgs 3
      btoi
      store 14 // asset_2_amount
      
      // if asset_1_amount:
        load 13 // asset_1_amount
        bz l12_end
        // then:
          // int asset_1_total_fee_amount [slot 15]
          // int asset_1_poolers_fee_amount [slot 16]
          // int asset_1_protocol_fee_amount [slot 17]
          // int asset_1_repayment_amount [slot 18]
          
          // asset_1_total_fee_amount, asset_1_poolers_fee_amount, asset_1_protocol_fee_amount = calculate_fixed_input_fee_amounts(asset_1_amount)
          load 13 // asset_1_amount
          callsub __func__calculate_fixed_input_fee_amounts
          store 15 // asset_1_total_fee_amount
          store 16 // asset_1_poolers_fee_amount
          store 17 // asset_1_protocol_fee_amount
          // asset_1_repayment_amount = asset_1_amount + asset_1_total_fee_amount
          load 13 // asset_1_amount
          load 15 // asset_1_total_fee_amount
          +
          store 18 // asset_1_repayment_amount
          // assert(asset_1_repayment_amount > asset_1_amount)
          load 18 // asset_1_repayment_amount
          load 13 // asset_1_amount
          >
          assert
          
          // int asset_1_txn_index [slot 19]
          // if asset_2_amount:
            load 14 // asset_2_amount
            bz l13_else
            // then:
              // asset_1_txn_index = Txn.GroupIndex - 2
              txn GroupIndex
              pushint 2
              -
              store 19 // asset_1_txn_index
            b l13_end
            l13_else:
            // else:
              // asset_1_txn_index = Txn.GroupIndex - 1
              txn GroupIndex
              pushint 1
              -
              store 19 // asset_1_txn_index
            l13_end: // end
          
          // assert(Gtxn[asset_1_txn_index].TypeEnum == Axfer)
          load 19 // asset_1_txn_index
          gtxns TypeEnum
          pushint 4 // Axfer
          ==
          assert
          // assert(Gtxn[asset_1_txn_index].AssetReceiver == pool_address)
          load 19 // asset_1_txn_index
          gtxns AssetReceiver
          load 1 // pool_address
          ==
          assert
          // assert(Gtxn[asset_1_txn_index].XferAsset == asset_1_id)
          load 19 // asset_1_txn_index
          gtxns XferAsset
          load 2 // asset_1_id
          ==
          assert
          // assert(Gtxn[asset_1_txn_index].AssetAmount >= asset_1_repayment_amount)
          load 19 // asset_1_txn_index
          gtxns AssetAmount
          load 18 // asset_1_repayment_amount
          >=
          assert
          
          // int asset_1_donation = Gtxn[asset_1_txn_index].AssetAmount - asset_1_repayment_amount [slot 20]
          load 19 // asset_1_txn_index
          gtxns AssetAmount
          load 18 // asset_1_repayment_amount
          -
          store 20 // asset_1_donation
          // if asset_1_donation:
            load 20 // asset_1_donation
            bz l14_end
            // then:
              // log(concat("asset_1_donation %i", itob(asset_1_donation)))
              pushbytes "asset_1_donation %i"
              load 20 // asset_1_donation
              itob
              concat
              log
            l14_end: // end
          
          // protocol_fees_asset_1 = protocol_fees_asset_1 + asset_1_protocol_fee_amount
          load 8 // protocol_fees_asset_1
          load 17 // asset_1_protocol_fee_amount
          +
          store 8 // protocol_fees_asset_1
          // asset_1_reserves = asset_1_reserves + asset_1_poolers_fee_amount
          load 5 // asset_1_reserves
          load 16 // asset_1_poolers_fee_amount
          +
          store 5 // asset_1_reserves
        l12_end: // end
      
      // if asset_2_amount:
        load 14 // asset_2_amount
        bz l15_end
        // then:
          // int asset_2_total_fee_amount [slot 21]
          // int asset_2_poolers_fee_amount [slot 22]
          // int asset_2_protocol_fee_amount [slot 23]
          // int asset_2_repayment_amount [slot 24]
          
          // asset_2_total_fee_amount, asset_2_poolers_fee_amount, asset_2_protocol_fee_amount = calculate_fixed_input_fee_amounts(asset_2_amount)
          load 14 // asset_2_amount
          callsub __func__calculate_fixed_input_fee_amounts
          store 21 // asset_2_total_fee_amount
          store 22 // asset_2_poolers_fee_amount
          store 23 // asset_2_protocol_fee_amount
          // asset_2_repayment_amount = asset_2_amount + asset_2_total_fee_amount
          load 14 // asset_2_amount
          load 21 // asset_2_total_fee_amount
          +
          store 24 // asset_2_repayment_amount
          // assert(asset_2_repayment_amount > asset_2_amount)
          load 24 // asset_2_repayment_amount
          load 14 // asset_2_amount
          >
          assert
          
          // int asset_2_txn_index = Txn.GroupIndex - 1 [slot 25]
          txn GroupIndex
          pushint 1
          -
          store 25 // asset_2_txn_index
          // int asset_2_donation = 0 [slot 26]
          pushint 0
          store 26 // asset_2_donation
          // if asset_2_id == 0:
            load 3 // asset_2_id
            pushint 0
            ==
            bz l16_else
            // then:
              // assert(Gtxn[asset_2_txn_index].TypeEnum == Pay)
              load 25 // asset_2_txn_index
              gtxns TypeEnum
              pushint 1 // Pay
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].Receiver == pool_address)
              load 25 // asset_2_txn_index
              gtxns Receiver
              load 1 // pool_address
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].Amount >= asset_2_repayment_amount)
              load 25 // asset_2_txn_index
              gtxns Amount
              load 24 // asset_2_repayment_amount
              >=
              assert
              // asset_2_donation = Gtxn[asset_2_txn_index].Amount - asset_2_repayment_amount
              load 25 // asset_2_txn_index
              gtxns Amount
              load 24 // asset_2_repayment_amount
              -
              store 26 // asset_2_donation
            b l16_end
            l16_else:
            // else:
              // assert(Gtxn[asset_2_txn_index].TypeEnum == Axfer)
              load 25 // asset_2_txn_index
              gtxns TypeEnum
              pushint 4 // Axfer
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].AssetReceiver == pool_address)
              load 25 // asset_2_txn_index
              gtxns AssetReceiver
              load 1 // pool_address
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].XferAsset == asset_2_id)
              load 25 // asset_2_txn_index
              gtxns XferAsset
              load 3 // asset_2_id
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].AssetAmount >= asset_2_repayment_amount)
              load 25 // asset_2_txn_index
              gtxns AssetAmount
              load 24 // asset_2_repayment_amount
              >=
              assert
              // asset_2_donation = Gtxn[asset_2_txn_index].AssetAmount - asset_2_repayment_amount
              load 25 // asset_2_txn_index
              gtxns AssetAmount
              load 24 // asset_2_repayment_amount
              -
              store 26 // asset_2_donation
            l16_end: // end
          
          // if asset_2_donation:
            load 26 // asset_2_donation
            bz l17_end
            // then:
              // log(concat("asset_2_donation %i", itob(asset_2_donation)))
              pushbytes "asset_2_donation %i"
              load 26 // asset_2_donation
              itob
              concat
              log
            l17_end: // end
          
          // protocol_fees_asset_2 = protocol_fees_asset_2 + asset_2_protocol_fee_amount
          load 9 // protocol_fees_asset_2
          load 23 // asset_2_protocol_fee_amount
          +
          store 9 // protocol_fees_asset_2
          // asset_2_reserves = asset_2_reserves + asset_2_poolers_fee_amount
          load 6 // asset_2_reserves
          load 22 // asset_2_poolers_fee_amount
          +
          store 6 // asset_2_reserves
        l15_end: // end
      
      // State updates
      // app_local_put(1, "asset_1_reserves", asset_1_reserves)
      pushint 1
      pushbytes "asset_1_reserves"
      load 5 // asset_1_reserves
      app_local_put
      // app_local_put(1, "asset_2_reserves", asset_2_reserves)
      pushint 1
      pushbytes "asset_2_reserves"
      load 6 // asset_2_reserves
      app_local_put
      // app_local_put(1, "protocol_fees_asset_1", protocol_fees_asset_1)
      pushint 1
      pushbytes "protocol_fees_asset_1"
      load 8 // protocol_fees_asset_1
      app_local_put
      // app_local_put(1, "protocol_fees_asset_2", protocol_fees_asset_2)
      pushint 1
      pushbytes "protocol_fees_asset_2"
      load 9 // protocol_fees_asset_2
      app_local_put
      // exit(1)
      pushint 1
      return
    
    // block flash_swap
    main__amm__flash_swap:
      // app_local_put(1, "lock", 1)
      pushint 1
      pushbytes "lock"
      pushint 1
      app_local_put
      
      // update_price_oracle()
      callsub main__amm__func__update_price_oracle
      // Gtxn[X]: Flash AppCall from User
      // itxn: Transfer Asset 1 to User from Pool if Asset 1 is requested
      // itxn: Transfer Asset 2 to User from Pool if Asset 2 is requested
      
      // int index_diff = btoi(Txn.ApplicationArgs[1]) [slot 11]
      txna ApplicationArgs 1
      btoi
      store 11 // index_diff
      // int asset_1_amount = btoi(Txn.ApplicationArgs[2]) [slot 12]
      txna ApplicationArgs 2
      btoi
      store 12 // asset_1_amount
      // int asset_2_amount = btoi(Txn.ApplicationArgs[3]) [slot 13]
      txna ApplicationArgs 3
      btoi
      store 13 // asset_2_amount
      // assert(asset_1_amount || asset_2_amount)
      load 12 // asset_1_amount
      load 13 // asset_2_amount
      ||
      assert
      
      // int verify_flash_swap_txn_index = Txn.GroupIndex + index_diff [slot 14]
      txn GroupIndex
      load 11 // index_diff
      +
      store 14 // verify_flash_swap_txn_index
      // assert(Gtxn[verify_flash_swap_txn_index].Sender == Txn.Sender)
      load 14 // verify_flash_swap_txn_index
      gtxns Sender
      txn Sender
      ==
      assert
      // assert(Gtxn[verify_flash_swap_txn_index].TypeEnum == Appl)
      load 14 // verify_flash_swap_txn_index
      gtxns TypeEnum
      pushint 6 // Appl
      ==
      assert
      // assert(Gtxn[verify_flash_swap_txn_index].ApplicationID == Global.CurrentApplicationID)
      load 14 // verify_flash_swap_txn_index
      gtxns ApplicationID
      global CurrentApplicationID
      ==
      assert
      // assert(Gtxn[verify_flash_swap_txn_index].ApplicationArgs[0] == "verify_flash_swap")
      load 14 // verify_flash_swap_txn_index
      gtxnsa ApplicationArgs 0
      pushbytes "verify_flash_swap"
      ==
      assert
      // assert(Gtxn[verify_flash_swap_txn_index].ApplicationArgs[1] == Txn.ApplicationArgs[1], "index_diff")
      load 14 // verify_flash_swap_txn_index
      gtxnsa ApplicationArgs 1
      txna ApplicationArgs 1
      ==
      assert // index_diff
      
      // if asset_1_amount:
        load 12 // asset_1_amount
        bz l18_end
        // then:
          // transfer_to_user(asset_1_id, asset_1_amount)
          load 2 // asset_1_id
          load 12 // asset_1_amount
          callsub main__amm__func__transfer_to_user
        l18_end: // end
      // if asset_2_amount:
        load 13 // asset_2_amount
        bz l19_end
        // then:
          // transfer_to_user(asset_2_id, asset_2_amount)
          load 3 // asset_2_id
          load 13 // asset_2_amount
          callsub main__amm__func__transfer_to_user
        l19_end: // end
      
      // log(itob(asset_1_reserves) b* itob(asset_2_reserves))
      load 5 // asset_1_reserves
      itob
      load 6 // asset_2_reserves
      itob
      b*
      log
      // log(itob(get_balance(1, asset_1_id)))
      pushint 1
      load 2 // asset_1_id
      callsub __func__get_balance
      itob
      log
      // log(itob(get_balance(1, asset_2_id)))
      pushint 1
      load 3 // asset_2_id
      callsub __func__get_balance
      itob
      log
      // exit(1)
      pushint 1
      return
    
    // block verify_flash_swap
    main__amm__verify_flash_swap:
      // if borrowed in two assets:
      // Gtxn[X-2]: Transfer Asset 1 to Pool
      // Gtxn[X-1]: Transfer Asset 2 to Pool
      // if borrowed single asset:
      // Gtxn[X-1]: Transfer borrowed Asset to Pool
      
      // Gtxn[X]: Verify Flash AppCall from User
      
      // int index_diff = btoi(Txn.ApplicationArgs[1]) [slot 11]
      txna ApplicationArgs 1
      btoi
      store 11 // index_diff
      // int flash_swap_txn_index = Txn.GroupIndex - index_diff [slot 12]
      txn GroupIndex
      load 11 // index_diff
      -
      store 12 // flash_swap_txn_index
      // assert(Gtxn[flash_swap_txn_index].TypeEnum == Appl)
      load 12 // flash_swap_txn_index
      gtxns TypeEnum
      pushint 6 // Appl
      ==
      assert
      // assert(Gtxn[flash_swap_txn_index].ApplicationID == Global.CurrentApplicationID)
      load 12 // flash_swap_txn_index
      gtxns ApplicationID
      global CurrentApplicationID
      ==
      assert
      // assert(Gtxn[flash_swap_txn_index].ApplicationArgs[0] == "flash_swap")
      load 12 // flash_swap_txn_index
      gtxnsa ApplicationArgs 0
      pushbytes "flash_swap"
      ==
      assert
      // assert(Gtxn[flash_swap_txn_index].ApplicationArgs[1] == Txn.ApplicationArgs[1], "index_diff")
      load 12 // flash_swap_txn_index
      gtxnsa ApplicationArgs 1
      txna ApplicationArgs 1
      ==
      assert // index_diff
      // int asset_1_amount = btoi(Gtxn[flash_swap_txn_index].ApplicationArgs[2]) [slot 13]
      load 12 // flash_swap_txn_index
      gtxnsa ApplicationArgs 2
      btoi
      store 13 // asset_1_amount
      // int asset_2_amount = btoi(Gtxn[flash_swap_txn_index].ApplicationArgs[3]) [slot 14]
      load 12 // flash_swap_txn_index
      gtxnsa ApplicationArgs 3
      btoi
      store 14 // asset_2_amount
      
      // byte initial_k = Gtxn[flash_swap_txn_index].Logs[0] [slot 15]
      load 12 // flash_swap_txn_index
      gtxnsa Logs 0
      store 15 // initial_k
      // int asset_1_balance_after_transfer = btoi(Gtxn[flash_swap_txn_index].Logs[1]) [slot 16]
      load 12 // flash_swap_txn_index
      gtxnsa Logs 1
      btoi
      store 16 // asset_1_balance_after_transfer
      // int asset_2_balance_after_transfer = btoi(Gtxn[flash_swap_txn_index].Logs[2]) [slot 17]
      load 12 // flash_swap_txn_index
      gtxnsa Logs 2
      btoi
      store 17 // asset_2_balance_after_transfer
      // int asset_1_balance = get_balance(1, asset_1_id) [slot 18]
      pushint 1
      load 2 // asset_1_id
      callsub __func__get_balance
      store 18 // asset_1_balance
      // int asset_2_balance = get_balance(1, asset_2_id) [slot 19]
      pushint 1
      load 3 // asset_2_id
      callsub __func__get_balance
      store 19 // asset_2_balance
      
      // int asset_1_in = 0 [slot 20]
      pushint 0
      store 20 // asset_1_in
      // int asset_2_in = 0 [slot 21]
      pushint 0
      store 21 // asset_2_in
      // if asset_1_balance > asset_1_balance_after_transfer:
        load 18 // asset_1_balance
        load 16 // asset_1_balance_after_transfer
        >
        bz l20_end
        // then:
          // asset_1_in = asset_1_balance - asset_1_balance_after_transfer
          load 18 // asset_1_balance
          load 16 // asset_1_balance_after_transfer
          -
          store 20 // asset_1_in
        l20_end: // end
      // if asset_2_balance > asset_2_balance_after_transfer:
        load 19 // asset_2_balance
        load 17 // asset_2_balance_after_transfer
        >
        bz l21_end
        // then:
          // asset_2_in = asset_2_balance - asset_2_balance_after_transfer
          load 19 // asset_2_balance
          load 17 // asset_2_balance_after_transfer
          -
          store 21 // asset_2_in
        l21_end: // end
      
      // int asset_1_total_fee_amount [slot 22]
      // int asset_1_poolers_fee_amount [slot 23]
      // int asset_1_protocol_fee_amount [slot 24]
      // if asset_1_in:
        load 20 // asset_1_in
        bz l22_else
        // then:
          // asset_1_total_fee_amount, asset_1_poolers_fee_amount, asset_1_protocol_fee_amount = calculate_fixed_input_fee_amounts(asset_1_in)
          load 20 // asset_1_in
          callsub __func__calculate_fixed_input_fee_amounts
          store 22 // asset_1_total_fee_amount
          store 23 // asset_1_poolers_fee_amount
          store 24 // asset_1_protocol_fee_amount
          // log(concat("asset_1_fee %i", itob(asset_1_total_fee_amount)))
          pushbytes "asset_1_fee %i"
          load 22 // asset_1_total_fee_amount
          itob
          concat
          log
          
          // protocol_fees_asset_1 = protocol_fees_asset_1 + asset_1_protocol_fee_amount
          load 8 // protocol_fees_asset_1
          load 24 // asset_1_protocol_fee_amount
          +
          store 8 // protocol_fees_asset_1
          // asset_1_reserves = (asset_1_reserves - asset_1_amount) + (asset_1_in - asset_1_protocol_fee_amount)
          load 5 // asset_1_reserves
          load 13 // asset_1_amount
          -
          load 20 // asset_1_in
          load 24 // asset_1_protocol_fee_amount
          -
          +
          store 5 // asset_1_reserves
        b l22_end
        l22_else:
        // else:
          // asset_1_poolers_fee_amount = 0
          pushint 0
          store 23 // asset_1_poolers_fee_amount
          // asset_1_reserves = asset_1_reserves - asset_1_amount
          load 5 // asset_1_reserves
          load 13 // asset_1_amount
          -
          store 5 // asset_1_reserves
        l22_end: // end
      
      // int asset_2_total_fee_amount [slot 25]
      // int asset_2_poolers_fee_amount [slot 26]
      // int asset_2_protocol_fee_amount [slot 27]
      // if asset_2_in:
        load 21 // asset_2_in
        bz l23_else
        // then:
          // asset_2_total_fee_amount, asset_2_poolers_fee_amount, asset_2_protocol_fee_amount = calculate_fixed_input_fee_amounts(asset_2_in)
          load 21 // asset_2_in
          callsub __func__calculate_fixed_input_fee_amounts
          store 25 // asset_2_total_fee_amount
          store 26 // asset_2_poolers_fee_amount
          store 27 // asset_2_protocol_fee_amount
          // log(concat("asset_2_fee %i", itob(asset_2_total_fee_amount)))
          pushbytes "asset_2_fee %i"
          load 25 // asset_2_total_fee_amount
          itob
          concat
          log
          
          // protocol_fees_asset_2 = protocol_fees_asset_2 + asset_2_protocol_fee_amount
          load 9 // protocol_fees_asset_2
          load 27 // asset_2_protocol_fee_amount
          +
          store 9 // protocol_fees_asset_2
          // asset_2_reserves = (asset_2_reserves - asset_2_amount) + (asset_2_in - asset_2_protocol_fee_amount)
          load 6 // asset_2_reserves
          load 14 // asset_2_amount
          -
          load 21 // asset_2_in
          load 27 // asset_2_protocol_fee_amount
          -
          +
          store 6 // asset_2_reserves
        b l23_end
        l23_else:
        // else:
          // asset_2_poolers_fee_amount = 0
          pushint 0
          store 26 // asset_2_poolers_fee_amount
          // asset_2_reserves = asset_2_reserves - asset_2_amount
          load 6 // asset_2_reserves
          load 14 // asset_2_amount
          -
          store 6 // asset_2_reserves
        l23_end: // end
      
      // assert(initial_k b< (itob(asset_1_reserves - asset_1_poolers_fee_amount) b* itob(asset_2_reserves - asset_2_poolers_fee_amount)), "Initial K < New K")
      load 15 // initial_k
      load 5 // asset_1_reserves
      load 23 // asset_1_poolers_fee_amount
      -
      itob
      load 6 // asset_2_reserves
      load 26 // asset_2_poolers_fee_amount
      -
      itob
      b*
      b<
      assert // Initial K < New K
      
      // State updates
      // app_local_put(1, "lock", 0)
      pushint 1
      pushbytes "lock"
      pushint 0
      app_local_put
      // app_local_put(1, "asset_1_reserves", asset_1_reserves)
      pushint 1
      pushbytes "asset_1_reserves"
      load 5 // asset_1_reserves
      app_local_put
      // app_local_put(1, "asset_2_reserves", asset_2_reserves)
      pushint 1
      pushbytes "asset_2_reserves"
      load 6 // asset_2_reserves
      app_local_put
      // app_local_put(1, "protocol_fees_asset_1", protocol_fees_asset_1)
      pushint 1
      pushbytes "protocol_fees_asset_1"
      load 8 // protocol_fees_asset_1
      app_local_put
      // app_local_put(1, "protocol_fees_asset_2", protocol_fees_asset_2)
      pushint 1
      pushbytes "protocol_fees_asset_2"
      load 9 // protocol_fees_asset_2
      app_local_put
      // exit(1)
      pushint 1
      return
    
    // block add_liquidity
    main__amm__add_liquidity:
      // Gtxn[0]: Transfer Asset1 to Pool from User
      // Gtxn[1]: Transfer Asset2 to Pool from User
      // Gtxn[2]: AppCall from User
      
      // itxn[0]: Transfer Pool Token to User from Pool
      // itxn[1]: Transfer Asset 1 or 2 to User from Pool (change)
      
      // int asset_1_txn_index = Txn.GroupIndex - 2 [slot 11]
      txn GroupIndex
      pushint 2
      -
      store 11 // asset_1_txn_index
      // assert(Gtxn[asset_1_txn_index].TypeEnum == Axfer)
      load 11 // asset_1_txn_index
      gtxns TypeEnum
      pushint 4 // Axfer
      ==
      assert
      // assert(Gtxn[asset_1_txn_index].AssetReceiver == pool_address)
      load 11 // asset_1_txn_index
      gtxns AssetReceiver
      load 1 // pool_address
      ==
      assert
      // assert(Gtxn[asset_1_txn_index].XferAsset == asset_1_id)
      load 11 // asset_1_txn_index
      gtxns XferAsset
      load 2 // asset_1_id
      ==
      assert
      // int asset_1_amount = Gtxn[asset_1_txn_index].AssetAmount [slot 12]
      load 11 // asset_1_txn_index
      gtxns AssetAmount
      store 12 // asset_1_amount
      
      // int asset_2_txn_index = Txn.GroupIndex - 1 [slot 13]
      txn GroupIndex
      pushint 1
      -
      store 13 // asset_2_txn_index
      // int asset_2_amount [slot 14]
      // if asset_2_id == 0:
        load 3 // asset_2_id
        pushint 0
        ==
        bz l24_else
        // then:
          // assert(Gtxn[asset_2_txn_index].TypeEnum == Pay)
          load 13 // asset_2_txn_index
          gtxns TypeEnum
          pushint 1 // Pay
          ==
          assert
          // assert(Gtxn[asset_2_txn_index].Receiver == pool_address)
          load 13 // asset_2_txn_index
          gtxns Receiver
          load 1 // pool_address
          ==
          assert
          // asset_2_amount = Gtxn[asset_2_txn_index].Amount
          load 13 // asset_2_txn_index
          gtxns Amount
          store 14 // asset_2_amount
        b l24_end
        l24_else:
        // else:
          // assert(Gtxn[asset_2_txn_index].TypeEnum == Axfer)
          load 13 // asset_2_txn_index
          gtxns TypeEnum
          pushint 4 // Axfer
          ==
          assert
          // assert(Gtxn[asset_2_txn_index].AssetReceiver == pool_address)
          load 13 // asset_2_txn_index
          gtxns AssetReceiver
          load 1 // pool_address
          ==
          assert
          // assert(Gtxn[asset_2_txn_index].XferAsset == asset_2_id)
          load 13 // asset_2_txn_index
          gtxns XferAsset
          load 3 // asset_2_id
          ==
          assert
          // asset_2_amount = Gtxn[asset_2_txn_index].AssetAmount
          load 13 // asset_2_txn_index
          gtxns AssetAmount
          store 14 // asset_2_amount
        l24_end: // end
      
      // int pool_tokens_out [slot 15]
      // if issued_pool_tokens:
        load 7 // issued_pool_tokens
        bz l25_else
        // then:
          // Adding liquidity after it already has some liquidity
          // byte a_temp = itob(asset_1_amount) b* itob(issued_pool_tokens) [slot 16]
          load 12 // asset_1_amount
          itob
          load 7 // issued_pool_tokens
          itob
          b*
          store 16 // a_temp
          // byte b_temp = itob(asset_2_amount) b* itob(issued_pool_tokens) [slot 17]
          load 14 // asset_2_amount
          itob
          load 7 // issued_pool_tokens
          itob
          b*
          store 17 // b_temp
          // int pool_tokens_out_a = btoi(a_temp b/ itob(asset_1_reserves)) [slot 18]
          load 16 // a_temp
          load 5 // asset_1_reserves
          itob
          b/
          btoi
          store 18 // pool_tokens_out_a
          // int pool_tokens_out_b = btoi(b_temp b/ itob(asset_2_reserves)) [slot 19]
          load 17 // b_temp
          load 6 // asset_2_reserves
          itob
          b/
          btoi
          store 19 // pool_tokens_out_b
          
          // if pool_tokens_out_a > pool_tokens_out_b:
            load 18 // pool_tokens_out_a
            load 19 // pool_tokens_out_b
            >
            bz l26_else
            // then:
              // Less of asset 2 supplied. Pool tokens will be issued proportionally to asset_2_amount (b)
              // Calculate amount of asset 1 to return to user as change
              // pool_tokens_out = pool_tokens_out_b
              load 19 // pool_tokens_out_b
              store 15 // pool_tokens_out
              // int expected_asset_1_amount = btoi((itob(pool_tokens_out) b* itob(asset_1_reserves)) b/ itob(issued_pool_tokens)) [slot 20]
              load 15 // pool_tokens_out
              itob
              load 5 // asset_1_reserves
              itob
              b*
              load 7 // issued_pool_tokens
              itob
              b/
              btoi
              store 20 // expected_asset_1_amount
              
              // Round Up if there is remainder
              // if btoi(b_temp b% itob(asset_2_reserves)):
                load 17 // b_temp
                load 6 // asset_2_reserves
                itob
                b%
                btoi
                bz l27_end
                // then:
                  // expected_asset_1_amount = expected_asset_1_amount + 1
                  load 20 // expected_asset_1_amount
                  pushint 1
                  +
                  store 20 // expected_asset_1_amount
                l27_end: // end
              
              // int asset_1_change = asset_1_amount - expected_asset_1_amount [slot 21]
              load 12 // asset_1_amount
              load 20 // expected_asset_1_amount
              -
              store 21 // asset_1_change
              // asset_1_amount = expected_asset_1_amount
              load 20 // expected_asset_1_amount
              store 12 // asset_1_amount
              // transfer_to_user(asset_1_id, asset_1_change)
              load 2 // asset_1_id
              load 21 // asset_1_change
              callsub main__amm__func__transfer_to_user
            b l26_end
            l26_else:
            // else:
              // Less of asset 1 supplied. Pool tokens will be issued proportionally to asset_1_amount (a)
              // Calculate amount of asset 2 to return to user as change
              // pool_tokens_out = pool_tokens_out_a
              load 18 // pool_tokens_out_a
              store 15 // pool_tokens_out
              // int expected_asset_2_amount = btoi((itob(pool_tokens_out) b* itob(asset_2_reserves)) b/ itob(issued_pool_tokens)) [slot 22]
              load 15 // pool_tokens_out
              itob
              load 6 // asset_2_reserves
              itob
              b*
              load 7 // issued_pool_tokens
              itob
              b/
              btoi
              store 22 // expected_asset_2_amount
              
              // Round Up if there is remainder
              // if btoi(a_temp b% itob(asset_1_reserves)):
                load 16 // a_temp
                load 5 // asset_1_reserves
                itob
                b%
                btoi
                bz l28_end
                // then:
                  // expected_asset_2_amount = expected_asset_2_amount + 1
                  load 22 // expected_asset_2_amount
                  pushint 1
                  +
                  store 22 // expected_asset_2_amount
                l28_end: // end
              
              // int asset_2_change = asset_2_amount - expected_asset_2_amount [slot 23]
              load 14 // asset_2_amount
              load 22 // expected_asset_2_amount
              -
              store 23 // asset_2_change
              // asset_2_amount = expected_asset_2_amount
              load 22 // expected_asset_2_amount
              store 14 // asset_2_amount
              // transfer_to_user(asset_2_id, asset_2_change)
              load 3 // asset_2_id
              load 23 // asset_2_change
              callsub main__amm__func__transfer_to_user
            l26_end: // end
          // issued_pool_tokens = issued_pool_tokens + pool_tokens_out
          load 7 // issued_pool_tokens
          load 15 // pool_tokens_out
          +
          store 7 // issued_pool_tokens
          // asset_1_reserves = asset_1_reserves + asset_1_amount
          load 5 // asset_1_reserves
          load 12 // asset_1_amount
          +
          store 5 // asset_1_reserves
          // asset_2_reserves = asset_2_reserves + asset_2_amount
          load 6 // asset_2_reserves
          load 14 // asset_2_amount
          +
          store 6 // asset_2_reserves
        b l25_end
        l25_else:
        // else:
          // Adding liquidity to the pool for the first time:
          // pool_tokens_out = sqrt(asset_1_amount * asset_2_amount) - LOCKED_POOL_TOKENS
          // issued_pool_tokens = btoi(bsqrt(itob(asset_1_amount) b* itob(asset_2_amount)))
          load 12 // asset_1_amount
          itob
          load 14 // asset_2_amount
          itob
          b*
          bsqrt
          btoi
          store 7 // issued_pool_tokens
          // pool_tokens_out = issued_pool_tokens - LOCKED_POOL_TOKENS
          load 7 // issued_pool_tokens
          pushint 1000 // LOCKED_POOL_TOKENS
          -
          store 15 // pool_tokens_out
          // asset_1_reserves = asset_1_amount
          load 12 // asset_1_amount
          store 5 // asset_1_reserves
          // asset_2_reserves = asset_2_amount
          load 14 // asset_2_amount
          store 6 // asset_2_reserves
        l25_end: // end
      
      // Ensure calculated amount of pool tokens is > 0
      // assert(pool_tokens_out)
      load 15 // pool_tokens_out
      assert
      // Send pool tokens to liquidity provider
      // transfer_to_user(pool_token_asset_id, pool_tokens_out)
      load 4 // pool_token_asset_id
      load 15 // pool_tokens_out
      callsub main__amm__func__transfer_to_user
      
      // State updates
      // app_local_put(1, "asset_1_reserves", asset_1_reserves)
      pushint 1
      pushbytes "asset_1_reserves"
      load 5 // asset_1_reserves
      app_local_put
      // app_local_put(1, "asset_2_reserves", asset_2_reserves)
      pushint 1
      pushbytes "asset_2_reserves"
      load 6 // asset_2_reserves
      app_local_put
      // app_local_put(1, "issued_pool_tokens", issued_pool_tokens)
      pushint 1
      pushbytes "issued_pool_tokens"
      load 7 // issued_pool_tokens
      app_local_put
      // exit(1)
      pushint 1
      return
    
    // block remove_liquidity
    main__amm__remove_liquidity:
      // Gtxn[0]: Transfer Pool Token to Pool from User
      // Gtxn[1]: AppCall from User
      
      // itxn[0]: Transfer Asset 1 to User from Pool
      // itxn[1]: Transfer Asset 2 to User from Pool
      
      // int pool_token_txn_index = Txn.GroupIndex - 1 [slot 11]
      txn GroupIndex
      pushint 1
      -
      store 11 // pool_token_txn_index
      // assert(Gtxn[pool_token_txn_index].TypeEnum == Axfer)
      load 11 // pool_token_txn_index
      gtxns TypeEnum
      pushint 4 // Axfer
      ==
      assert
      // assert(Gtxn[pool_token_txn_index].AssetReceiver == pool_address)
      load 11 // pool_token_txn_index
      gtxns AssetReceiver
      load 1 // pool_address
      ==
      assert
      // assert(Gtxn[pool_token_txn_index].XferAsset == pool_token_asset_id)
      load 11 // pool_token_txn_index
      gtxns XferAsset
      load 4 // pool_token_asset_id
      ==
      assert
      // int removed_pool_token_amount = Gtxn[pool_token_txn_index].AssetAmount [slot 12]
      load 11 // pool_token_txn_index
      gtxns AssetAmount
      store 12 // removed_pool_token_amount
      
      // int asset_1_amount [slot 13]
      // int asset_2_amount [slot 14]
      // if (removed_pool_token_amount + LOCKED_POOL_TOKENS) == issued_pool_tokens:
        load 12 // removed_pool_token_amount
        pushint 1000 // LOCKED_POOL_TOKENS
        +
        load 7 // issued_pool_tokens
        ==
        bz l29_else
        // then:
          // asset_1_amount = asset_1_reserves
          load 5 // asset_1_reserves
          store 13 // asset_1_amount
          // asset_2_amount = asset_2_reserves
          load 6 // asset_2_reserves
          store 14 // asset_2_amount
          // removed_pool_token_amount = issued_pool_tokens
          load 7 // issued_pool_tokens
          store 12 // removed_pool_token_amount
        b l29_end
        l29_else:
        // else:
          // asset_1_amount = btoi((itob(removed_pool_token_amount) b* itob(asset_1_reserves)) b/ itob(issued_pool_tokens))
          load 12 // removed_pool_token_amount
          itob
          load 5 // asset_1_reserves
          itob
          b*
          load 7 // issued_pool_tokens
          itob
          b/
          btoi
          store 13 // asset_1_amount
          // asset_2_amount = btoi((itob(removed_pool_token_amount) b* itob(asset_2_reserves)) b/ itob(issued_pool_tokens))
          load 12 // removed_pool_token_amount
          itob
          load 6 // asset_2_reserves
          itob
          b*
          load 7 // issued_pool_tokens
          itob
          b/
          btoi
          store 14 // asset_2_amount
        l29_end: // end
      
      // assert(asset_1_amount && asset_2_amount)
      load 13 // asset_1_amount
      load 14 // asset_2_amount
      &&
      assert
      // transfer_to_user(asset_1_id, asset_1_amount)
      load 2 // asset_1_id
      load 13 // asset_1_amount
      callsub main__amm__func__transfer_to_user
      // transfer_to_user(asset_2_id, asset_2_amount)
      load 3 // asset_2_id
      load 14 // asset_2_amount
      callsub main__amm__func__transfer_to_user
      
      // State updates
      // app_local_put(1, "asset_1_reserves", asset_1_reserves - asset_1_amount)
      pushint 1
      pushbytes "asset_1_reserves"
      load 5 // asset_1_reserves
      load 13 // asset_1_amount
      -
      app_local_put
      // app_local_put(1, "asset_2_reserves", asset_2_reserves - asset_2_amount)
      pushint 1
      pushbytes "asset_2_reserves"
      load 6 // asset_2_reserves
      load 14 // asset_2_amount
      -
      app_local_put
      // app_local_put(1, "issued_pool_tokens", issued_pool_tokens - removed_pool_token_amount)
      pushint 1
      pushbytes "issued_pool_tokens"
      load 7 // issued_pool_tokens
      load 12 // removed_pool_token_amount
      -
      app_local_put
      // exit(1)
      pushint 1
      return
    
    // func transfer_to_user(asset_id: int, amount: int):
    main__amm__func__transfer_to_user:
    store 28 // amount
    store 29 // asset_id
    // return transfer(asset_id, amount, pool_address, user_address)
    load 29 // asset_id
    load 28 // amount
    load 1 // pool_address
    load 0 // user_address
    callsub __func__transfer
    retsub
    
    // func update_price_oracle():
    main__amm__func__update_price_oracle:
    // byte cumulative_asset_1_price = app_local_get(1, "cumulative_asset_1_price") [slot 30]
    pushint 1
    pushbytes "cumulative_asset_1_price"
    app_local_get
    store 30 // cumulative_asset_1_price
    // byte cumulative_asset_2_price = app_local_get(1, "cumulative_asset_2_price") [slot 31]
    pushint 1
    pushbytes "cumulative_asset_2_price"
    app_local_get
    store 31 // cumulative_asset_2_price
    // int time_delta = Global.LatestTimestamp - app_local_get(1, "cumulative_price_update_timestamp") [slot 32]
    global LatestTimestamp
    pushint 1
    pushbytes "cumulative_price_update_timestamp"
    app_local_get
    -
    store 32 // time_delta
    
    // if (issued_pool_tokens && time_delta):
      load 7 // issued_pool_tokens
      load 32 // time_delta
      &&
      bz l30_end
      // then:
        // cumulative_asset_1_price = cumulative_asset_1_price b+ (((itob(asset_2_reserves) b* TWO_TO_THE_64) b* itob(time_delta)) b/ itob(asset_1_reserves))
        load 30 // cumulative_asset_1_price
        load 6 // asset_2_reserves
        itob
        pushbytes "\x01\x00\x00\x00\x00\x00\x00\x00\x00" // TWO_TO_THE_64
        b*
        load 32 // time_delta
        itob
        b*
        load 5 // asset_1_reserves
        itob
        b/
        b+
        store 30 // cumulative_asset_1_price
        // cumulative_asset_2_price = cumulative_asset_2_price b+ (((itob(asset_1_reserves) b* TWO_TO_THE_64) b* itob(time_delta)) b/ itob(asset_2_reserves))
        load 31 // cumulative_asset_2_price
        load 5 // asset_1_reserves
        itob
        pushbytes "\x01\x00\x00\x00\x00\x00\x00\x00\x00" // TWO_TO_THE_64
        b*
        load 32 // time_delta
        itob
        b*
        load 6 // asset_2_reserves
        itob
        b/
        b+
        store 31 // cumulative_asset_2_price
        // app_local_put(1, "cumulative_asset_1_price", cumulative_asset_1_price)
        pushint 1
        pushbytes "cumulative_asset_1_price"
        load 30 // cumulative_asset_1_price
        app_local_put
        // app_local_put(1, "cumulative_asset_2_price", cumulative_asset_2_price)
        pushint 1
        pushbytes "cumulative_asset_2_price"
        load 31 // cumulative_asset_2_price
        app_local_put
        // app_local_put(1, "cumulative_price_update_timestamp", Global.LatestTimestamp)
        pushint 1
        pushbytes "cumulative_price_update_timestamp"
        global LatestTimestamp
        app_local_put
      l30_end: // end
    // return
    retsub


// func calculate_fixed_input_fee_amounts(input_amount: int) int:
__func__calculate_fixed_input_fee_amounts:
store 33 // input_amount
// int poolers_fee_share = app_local_get(1, "poolers_fee_share") [slot 34]
pushint 1
pushbytes "poolers_fee_share"
app_local_get
store 34 // poolers_fee_share
// int protocol_fee_share = app_local_get(1, "protocol_fee_share") [slot 35]
pushint 1
pushbytes "protocol_fee_share"
app_local_get
store 35 // protocol_fee_share

// int total_fee_share = poolers_fee_share + protocol_fee_share [slot 36]
load 34 // poolers_fee_share
load 35 // protocol_fee_share
+
store 36 // total_fee_share
// int total_fee = (input_amount * total_fee_share) / 10000 [slot 37]
load 33 // input_amount
load 36 // total_fee_share
*
pushint 10000
/
store 37 // total_fee
// int protocol_fee = (total_fee * protocol_fee_share) / total_fee_share [slot 38]
load 37 // total_fee
load 35 // protocol_fee_share
*
load 36 // total_fee_share
/
store 38 // protocol_fee
// int poolers_fee = total_fee - protocol_fee [slot 39]
load 37 // total_fee
load 38 // protocol_fee
-
store 39 // poolers_fee
// return total_fee, poolers_fee, protocol_fee
load 38 // protocol_fee
load 39 // poolers_fee
load 37 // total_fee
retsub


// func calculate_fixed_output_fee_amounts(swap_amount: int) int:
__func__calculate_fixed_output_fee_amounts:
store 40 // swap_amount
// int poolers_fee_share = app_local_get(1, "poolers_fee_share") [slot 41]
pushint 1
pushbytes "poolers_fee_share"
app_local_get
store 41 // poolers_fee_share
// int protocol_fee_share = app_local_get(1, "protocol_fee_share") [slot 42]
pushint 1
pushbytes "protocol_fee_share"
app_local_get
store 42 // protocol_fee_share
// int input_amount = (swap_amount * 10000) / (10000 - (poolers_fee_share + protocol_fee_share)) [slot 43]
load 40 // swap_amount
pushint 10000
*
pushint 10000
load 41 // poolers_fee_share
load 42 // protocol_fee_share
+
-
/
store 43 // input_amount

// int total_fee_share = poolers_fee_share + protocol_fee_share [slot 44]
load 41 // poolers_fee_share
load 42 // protocol_fee_share
+
store 44 // total_fee_share
// int total_fee = (input_amount * total_fee_share) / 10000 [slot 45]
load 43 // input_amount
load 44 // total_fee_share
*
pushint 10000
/
store 45 // total_fee
// int protocol_fee = (total_fee * protocol_fee_share) / total_fee_share [slot 46]
load 45 // total_fee
load 42 // protocol_fee_share
*
load 44 // total_fee_share
/
store 46 // protocol_fee
// int poolers_fee = total_fee - protocol_fee [slot 47]
load 45 // total_fee
load 46 // protocol_fee
-
store 47 // poolers_fee
// return total_fee, poolers_fee, protocol_fee
load 46 // protocol_fee
load 47 // poolers_fee
load 45 // total_fee
retsub


// func calculate_fixed_input_swap(input_supply: int, output_supply: int, swap_amount: int) int:
__func__calculate_fixed_input_swap:
store 48 // swap_amount
store 49 // output_supply
store 50 // input_supply
// Calculates the output amount for a fixed-input swap ignoring fees
// k = input_supply * output_supply
// output_amount = output_supply - (k / (input_supply + swap_amount))
// byte k = itob(input_supply) b* itob(output_supply) [slot 51]
load 50 // input_supply
itob
load 49 // output_supply
itob
b*
store 51 // k
// +1 for Round Up
// int output_amount = output_supply - (btoi((k b/ itob(input_supply + swap_amount))) + 1) [slot 52]
load 49 // output_supply
load 51 // k
load 50 // input_supply
load 48 // swap_amount
+
itob
b/
btoi
pushint 1
+
-
store 52 // output_amount
// return output_amount
load 52 // output_amount
retsub


// func calculate_fixed_output_swap(input_supply: int, output_supply: int, output_amount: int) int:
__func__calculate_fixed_output_swap:
store 53 // output_amount
store 54 // output_supply
store 55 // input_supply
// Calculates the input amount for a fixed-output swap ignoring fees
// k = input_supply * output_supply
// input_amount = (k / (output_supply - asset_out_amount)) - input_supply
// byte k = itob(input_supply) b* itob(output_supply) [slot 56]
load 55 // input_supply
itob
load 54 // output_supply
itob
b*
store 56 // k
// +1 for Round Up
// int input_amount = (btoi((k b/ itob(output_supply - output_amount))) + 1) - input_supply [slot 57]
load 56 // k
load 54 // output_supply
load 53 // output_amount
-
itob
b/
btoi
pushint 1
+
load 55 // input_supply
-
store 57 // input_amount
// return input_amount
load 57 // input_amount
retsub


// func get_balance(account_idx: int, asset_id: int) int:
__func__get_balance:
store 58 // asset_id
store 59 // account_idx
// int balance = 0 [slot 60]
pushint 0
store 60 // balance
// if asset_id == 0:
  load 58 // asset_id
  pushint 0
  ==
  bz l31_else
  // then:
    // balance = balance(account_idx) - min_balance(account_idx)
    load 59 // account_idx
    balance
    load 59 // account_idx
    min_balance
    -
    store 60 // balance
  b l31_end
  l31_else:
  // else:
    // _, balance = asset_holding_get(AssetBalance, account_idx, asset_id)
    load 59 // account_idx
    load 58 // asset_id
    asset_holding_get AssetBalance
    pop // discarding value for _
    store 60 // balance
  l31_end: // end
// return balance
load 60 // balance
retsub


// func transfer(asset_id: int, amount: int, sender: byte, receiver: byte):
__func__transfer:
store 61 // receiver
store 62 // sender
store 63 // amount
store 64 // asset_id
// if asset_id == 0:
  load 64 // asset_id
  pushint 0
  ==
  bz l32_else
  // then:
    // 
    itxn_begin
    // inner_txn:
    pushint 1 // Pay
    itxn_field TypeEnum
    load 62 // sender
    itxn_field Sender
    load 61 // receiver
    itxn_field Receiver
    load 63 // amount
    itxn_field Amount
    pushint 0
    itxn_field Fee
    itxn_submit
  b l32_end
  l32_else:
  // else:
    // 
    itxn_begin
    // inner_txn:
    pushint 4 // Axfer
    itxn_field TypeEnum
    load 62 // sender
    itxn_field Sender
    load 61 // receiver
    itxn_field AssetReceiver
    load 63 // amount
    itxn_field AssetAmount
    load 64 // asset_id
    itxn_field XferAsset
    pushint 0
    itxn_field Fee
    itxn_submit
  l32_end: // end
// return
retsub

