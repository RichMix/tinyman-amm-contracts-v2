#pragma version 7

// NOTE: Tinyman assumes that the asset id of ALGO is 0. Algorand cannot have an ASA with id 0.

// NOTE: Fee should be set to 0 for all inner transactions to ensure it is paid by an outer transaction sender instead of the Pool.
// No need for further fee checks.


// if Txn.ApplicationID == 0:
  txn ApplicationID
  pushint 0
  ==
  bz l0_end
  // then:
    // create app
    // app_global_put("fee_setter", Txn.Sender)
    pushbytes "fee_setter"
    txn Sender
    app_global_put
    // app_global_put("fee_collector", Txn.Sender)
    pushbytes "fee_collector"
    txn Sender
    app_global_put
    // app_global_put("fee_manager", Txn.Sender)
    pushbytes "fee_manager"
    txn Sender
    app_global_put
    // exit(1)
    pushint 1
    return
  l0_end: // end

// switch Txn.OnCompletion:
txn OnCompletion
pushint 0 // NoOp
==
bnz main
txn OnCompletion
pushint 1 // OptIn
==
bnz bootstrap
txn OnCompletion
pushint 2 // CloseOut
==
bnz handle_closeout
txn OnCompletion
pushint 4 // UpdateApplication
==
bnz handle_updateapp
txn OnCompletion
pushint 5 // DeleteApplication
==
bnz handle_deleteapp
err // unexpected value

// block handle_updateapp
handle_updateapp:
  // exit(0)
  pushint 0
  return

// block handle_deleteapp
handle_deleteapp:
  // exit(0)
  pushint 0
  return

// block handle_closeout
handle_closeout:
  // exit(0)
  pushint 0
  return

// block bootstrap
bootstrap:
  // Prerequisite: Pay Algo to Pool Address from User to cover minimum balance
  
  // Txn: AppCall with Optin from Pool Address to Bootstrap pool & ReKey to Application
  // itxn[0]: Pay Algo from Pool to Application
  // itxn[1]: Create Pool Token Asset from Application
  // itxn[2]: Optin Pool to Asset 1
  // itxn[3]: Optin Pool to Asset 2
  // itxn[4]: Optin Pool to Pool Token Asset
  // itxn[5]: Transfer Pool Token total supply to Pool Account
  
  // Should fail if:
  // Pool Address (Sender) != SHA512_256("program" + bytes from template and args)
  // Address already opted in to app
  // Required Algo is not sent to the pool address to cover minimum balance
  
  // assert(Txn.ApplicationArgs[0] == "bootstrap")
  txna ApplicationArgs 0
  pushbytes "bootstrap"
  ==
  assert
  
  // Ensure Txn includes rekey to application address
  // assert(Txn.RekeyTo == Global.CurrentApplicationAddress)
  txn RekeyTo
  global CurrentApplicationAddress
  ==
  assert
  
  // int asset_1_id = Txn.Assets[0] [slot 0]
  txna Assets 0
  store 0 // asset_1_id
  // int asset_2_id = Txn.Assets[1] [slot 1]
  txna Assets 1
  store 1 // asset_2_id
  // assert(asset_1_id > asset_2_id)
  load 0 // asset_1_id
  load 1 // asset_2_id
  >
  assert
  
  // bytes pool_address = Txn.Sender [slot 2]
  txn Sender
  store 2 // pool_address
  // int exists [slot 3]
  // bytes asset_1_unit_name [slot 4]
  // bytes asset_2_unit_name [slot 5]
  // int asset_total [slot 6]
  
  // exists, asset_1_unit_name = asset_params_get(AssetUnitName, asset_1_id)
  load 0 // asset_1_id
  asset_params_get AssetUnitName
  store 3 // exists
  store 4 // asset_1_unit_name
  // assert(exists)
  load 3 // exists
  assert
  // Ensure Asset 1 has total supply >= ASSET_MIN_TOTAL
  // _, asset_total = asset_params_get(AssetTotal, asset_1_id)
  load 0 // asset_1_id
  asset_params_get AssetTotal
  pop // discarding value for _
  store 6 // asset_total
  // assert(asset_total >= ASSET_MIN_TOTAL)
  load 6 // asset_total
  pushint 10000 // ASSET_MIN_TOTAL
  >=
  assert
  
  // if asset_2_id == 0:
    load 1 // asset_2_id
    pushint 0
    ==
    bz l1_else
    // then:
      // asset_2_unit_name = "ALGO"
      pushbytes "ALGO"
      store 5 // asset_2_unit_name
    b l1_end
    l1_else:
    // else:
      // exists, asset_2_unit_name = asset_params_get(AssetUnitName, asset_2_id)
      load 1 // asset_2_id
      asset_params_get AssetUnitName
      store 3 // exists
      store 5 // asset_2_unit_name
      // assert(exists)
      load 3 // exists
      assert
      // Ensure Asset 2 has total supply >= ASSET_MIN_TOTAL
      // _, asset_total = asset_params_get(AssetTotal, asset_2_id)
      load 1 // asset_2_id
      asset_params_get AssetTotal
      pop // discarding value for _
      store 6 // asset_total
      // assert(asset_total >= ASSET_MIN_TOTAL)
      load 6 // asset_total
      pushint 10000 // ASSET_MIN_TOTAL
      >=
      assert
    l1_end: // end
  
  // bytes pool_token_asset_name = concat("TinymanPool2.0 ", concat(concat(asset_1_unit_name, "-"), asset_2_unit_name)) [slot 7]
  pushbytes "TinymanPool2.0 "
  load 4 // asset_1_unit_name
  pushbytes "-"
  concat
  load 5 // asset_2_unit_name
  concat
  concat
  store 7 // pool_token_asset_name
  
  // Ensure pool_address == SHA512_256("program" + bytes from template and args)
  // bytes program = replace2(3, POOL_TEMPLATE, itob(Global.CurrentApplicationID)) [slot 8]
  pushbytes "\x06\x80\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x81\x00[5\x004\x001\x18\x12D1\x19\x81\x01\x12D\x81\x01C" // POOL_TEMPLATE
  global CurrentApplicationID
  itob
  replace2 3
  store 8 // program
  // program = replace2(11, program, itob(asset_1_id))
  load 8 // program
  load 0 // asset_1_id
  itob
  replace2 11
  store 8 // program
  // program = replace2(19, program, itob(asset_2_id))
  load 8 // program
  load 1 // asset_2_id
  itob
  replace2 19
  store 8 // program
  // assert(pool_address == sha512_256(concat("Program", program)))
  load 2 // pool_address
  pushbytes "Program"
  load 8 // program
  concat
  sha512_256
  ==
  assert
  
  // Use the metadata hash field of the Pool Token asset to store the asset_1_id & asset_2_id.
  // uint64 (8 bytes) + uint64 (8 bytes) + zeros (16 bytes)
  // bytes metadata_hash = concat(itob(asset_1_id), concat(itob(asset_2_id), bzero(16))) [slot 9]
  load 0 // asset_1_id
  itob
  load 1 // asset_2_id
  itob
  pushint 16
  bzero
  concat
  concat
  store 9 // metadata_hash
  
  // itxn[0]: Pay Algo from Pool to Application to fund minimum balance increase because of asset Creation
  // 
  itxn_begin
  // inner_txn:
  pushint 1 // Pay
  itxn_field TypeEnum
  load 2 // pool_address
  itxn_field Sender
  global CurrentApplicationAddress
  itxn_field Receiver
  pushint 100000
  itxn_field Amount
  pushint 0
  itxn_field Fee
  itxn_submit
  
  // itxn[1]: Create Pool Token Asset from Application Address
  // 
  itxn_begin
  // inner_txn:
  pushint 3 // Acfg
  itxn_field TypeEnum
  global CurrentApplicationAddress
  itxn_field Sender
  pushbytes "TMPOOL2"
  itxn_field ConfigAssetUnitName
  load 7 // pool_token_asset_name
  itxn_field ConfigAssetName
  pushint 18446744073709551615 // POOL_TOKEN_TOTAL_SUPPLY
  itxn_field ConfigAssetTotal
  pushint 6
  itxn_field ConfigAssetDecimals
  pushbytes "https://tinyman.org"
  itxn_field ConfigAssetURL
  load 2 // pool_address
  itxn_field ConfigAssetReserve
  load 9 // metadata_hash
  itxn_field ConfigAssetMetadataHash
  pushint 0
  itxn_field Fee
  itxn_submit
  
  // Get the id of the asset just created
  // int pool_token_asset_id = Itxn.CreatedAssetID [slot 10]
  itxn CreatedAssetID
  store 10 // pool_token_asset_id
  
  // itxn[2]: Optin Pool to Asset 1
  // 
  itxn_begin
  // inner_txn:
  pushint 4 // Axfer
  itxn_field TypeEnum
  load 2 // pool_address
  itxn_field Sender
  load 2 // pool_address
  itxn_field AssetReceiver
  load 0 // asset_1_id
  itxn_field XferAsset
  pushint 0
  itxn_field Amount
  pushint 0
  itxn_field Fee
  itxn_submit
  
  // itxn[3]: Optin Pool to Asset 2
  // if asset_2_id > 0:
    load 1 // asset_2_id
    pushint 0
    >
    bz l2_end
    // then:
      // 
      itxn_begin
      // inner_txn:
      pushint 4 // Axfer
      itxn_field TypeEnum
      load 2 // pool_address
      itxn_field Sender
      load 2 // pool_address
      itxn_field AssetReceiver
      load 1 // asset_2_id
      itxn_field XferAsset
      pushint 0
      itxn_field Amount
      pushint 0
      itxn_field Fee
      itxn_submit
    l2_end: // end
  
  // itxn[4]: Optin Pool to Pool Token Asset
  // 
  itxn_begin
  // inner_txn:
  pushint 4 // Axfer
  itxn_field TypeEnum
  load 2 // pool_address
  itxn_field Sender
  load 2 // pool_address
  itxn_field AssetReceiver
  load 10 // pool_token_asset_id
  itxn_field XferAsset
  pushint 0
  itxn_field Amount
  pushint 0
  itxn_field Fee
  itxn_submit
  
  // itxn[5]: Transfer Pool Token total supply to Pool Account
  // 
  itxn_begin
  // inner_txn:
  pushint 4 // Axfer
  itxn_field TypeEnum
  global CurrentApplicationAddress
  itxn_field Sender
  load 2 // pool_address
  itxn_field AssetReceiver
  load 10 // pool_token_asset_id
  itxn_field XferAsset
  pushint 18446744073709551615 // POOL_TOKEN_TOTAL_SUPPLY
  itxn_field AssetAmount
  pushint 0
  itxn_field Fee
  itxn_submit
  
  // State updates
  // [asset_1]
  // [asset_2]
  // [pool_token_asset_id]
  // app_local_put(0, "asset_1_id", asset_1_id)
  pushint 0
  pushbytes "asset_1_id"
  load 0 // asset_1_id
  app_local_put
  // app_local_put(0, "asset_2_id", asset_2_id)
  pushint 0
  pushbytes "asset_2_id"
  load 1 // asset_2_id
  app_local_put
  // app_local_put(0, "pool_token_asset_id", pool_token_asset_id)
  pushint 0
  pushbytes "pool_token_asset_id"
  load 10 // pool_token_asset_id
  app_local_put
  
  // Set all remaining keys with initials values
  // app_local_put(0, "total_fee_share", 30)
  pushint 0
  pushbytes "total_fee_share"
  pushint 30
  app_local_put
  // app_local_put(0, "protocol_fee_ratio", 6)
  pushint 0
  pushbytes "protocol_fee_ratio"
  pushint 6
  app_local_put
  // app_local_put(0, "asset_1_reserves", 0)
  pushint 0
  pushbytes "asset_1_reserves"
  pushint 0
  app_local_put
  // app_local_put(0, "asset_2_reserves", 0)
  pushint 0
  pushbytes "asset_2_reserves"
  pushint 0
  app_local_put
  // app_local_put(0, "issued_pool_tokens", 0)
  pushint 0
  pushbytes "issued_pool_tokens"
  pushint 0
  app_local_put
  // app_local_put(0, "asset_1_protocol_fees", 0)
  pushint 0
  pushbytes "asset_1_protocol_fees"
  pushint 0
  app_local_put
  // app_local_put(0, "asset_2_protocol_fees", 0)
  pushint 0
  pushbytes "asset_2_protocol_fees"
  pushint 0
  app_local_put
  // app_local_put(0, "lock", 0)
  pushint 0
  pushbytes "lock"
  pushint 0
  app_local_put
  // app_local_put(0, "asset_1_cumulative_price", BYTE_ZERO)
  pushint 0
  pushbytes "asset_1_cumulative_price"
  pushbytes "\x00\x00\x00\x00\x00\x00\x00\x00" // BYTE_ZERO
  app_local_put
  // app_local_put(0, "asset_2_cumulative_price", BYTE_ZERO)
  pushint 0
  pushbytes "asset_2_cumulative_price"
  pushbytes "\x00\x00\x00\x00\x00\x00\x00\x00" // BYTE_ZERO
  app_local_put
  // app_local_put(0, "cumulative_price_update_timestamp", Global.LatestTimestamp)
  pushint 0
  pushbytes "cumulative_price_update_timestamp"
  global LatestTimestamp
  app_local_put
  // exit(1)
  pushint 1
  return

// block main
main:
  // bytes user_address = Txn.Sender [slot 0]
  txn Sender
  store 0 // user_address
  // switch Txn.ApplicationArgs[0]:
  txna ApplicationArgs 0
  pushbytes "set_fee_collector"
  ==
  bnz main__set_fee_collector
  txna ApplicationArgs 0
  pushbytes "set_fee_setter"
  ==
  bnz main__set_fee_setter
  txna ApplicationArgs 0
  pushbytes "set_fee_manager"
  ==
  bnz main__set_fee_manager
  txna ApplicationArgs 0
  pushbytes "claim_fees"
  ==
  bnz main__claim_fees
  txna ApplicationArgs 0
  pushbytes "claim_extra"
  ==
  bnz main__claim_extra
  txna ApplicationArgs 0
  pushbytes "set_fee"
  ==
  bnz main__set_fee
  b main__amm // else
  
  // block set_fee_collector
  main__set_fee_collector:
    // Set a new fee collector, only fee manager can call this method
    // Txn: AppCall from fee_manager
    
    // assert(user_address == app_global_get("fee_manager"))
    load 0 // user_address
    pushbytes "fee_manager"
    app_global_get
    ==
    assert
    
    // State updates
    // [fee_collector]
    // app_global_put("fee_collector", Txn.Accounts[1])
    pushbytes "fee_collector"
    txna Accounts 1
    app_global_put
    // exit(1)
    pushint 1
    return
  
  // block set_fee_setter
  main__set_fee_setter:
    // Set a new fee setter, only fee manager can call this method
    // Txn: AppCall from fee_manager
    
    // assert(user_address == app_global_get("fee_manager"))
    load 0 // user_address
    pushbytes "fee_manager"
    app_global_get
    ==
    assert
    
    // State updates
    // [fee_setter]
    // app_global_put("fee_setter", Txn.Accounts[1])
    pushbytes "fee_setter"
    txna Accounts 1
    app_global_put
    // exit(1)
    pushint 1
    return
  
  // block set_fee_manager
  main__set_fee_manager:
    // Set a new fee manager, only fee manager can call this method
    // Txn: AppCall from fee_manager
    
    // assert(user_address == app_global_get("fee_manager"))
    load 0 // user_address
    pushbytes "fee_manager"
    app_global_get
    ==
    assert
    
    // State updates
    // [fee_manager]
    // app_global_put("fee_manager", Txn.Accounts[1])
    pushbytes "fee_manager"
    txna Accounts 1
    app_global_put
    // exit(1)
    pushint 1
    return
  
  // block claim_fees
  main__claim_fees:
    // Transfer accumulated fees from the pool to the fee_collector
    // Txn: AppCall from User
    // itxn[0]: Transfer Asset 1 to fee_collector from Pool
    // itxn[1]: Transfer Asset 2 to fee_collector from Pool
    
    // bytes pool_address = Txn.Accounts[1] [slot 1]
    txna Accounts 1
    store 1 // pool_address
    // int asset_1_id = app_local_get(1, "asset_1_id") [slot 2]
    pushint 1
    pushbytes "asset_1_id"
    app_local_get
    store 2 // asset_1_id
    // int asset_2_id = app_local_get(1, "asset_2_id") [slot 3]
    pushint 1
    pushbytes "asset_2_id"
    app_local_get
    store 3 // asset_2_id
    // int asset_1_protocol_fees = app_local_get(1, "asset_1_protocol_fees") [slot 4]
    pushint 1
    pushbytes "asset_1_protocol_fees"
    app_local_get
    store 4 // asset_1_protocol_fees
    // int asset_2_protocol_fees = app_local_get(1, "asset_2_protocol_fees") [slot 5]
    pushint 1
    pushbytes "asset_2_protocol_fees"
    app_local_get
    store 5 // asset_2_protocol_fees
    
    // assert(asset_1_protocol_fees || asset_2_protocol_fees)
    load 4 // asset_1_protocol_fees
    load 5 // asset_2_protocol_fees
    ||
    assert
    // transfer(asset_1_id, asset_1_protocol_fees, pool_address, app_global_get("fee_collector"))
    load 2 // asset_1_id
    load 4 // asset_1_protocol_fees
    load 1 // pool_address
    pushbytes "fee_collector"
    app_global_get
    callsub __func__transfer
    // transfer(asset_2_id, asset_2_protocol_fees, pool_address, app_global_get("fee_collector"))
    load 3 // asset_2_id
    load 5 // asset_2_protocol_fees
    load 1 // pool_address
    pushbytes "fee_collector"
    app_global_get
    callsub __func__transfer
    
    // State updates
    // app_local_put(1, "asset_1_protocol_fees", 0)
    pushint 1
    pushbytes "asset_1_protocol_fees"
    pushint 0
    app_local_put
    // app_local_put(1, "asset_2_protocol_fees", 0)
    pushint 1
    pushbytes "asset_2_protocol_fees"
    pushint 0
    app_local_put
    // exit(1)
    pushint 1
    return
  
  // block claim_extra
  main__claim_extra:
    // Transfer any extra (donations) to the fee_collector
    
    // Txn: AppCall from User
    // NOTE: must account for min balance when asset_2 is algo
    // itxn[0]: Transfer Asset 1 to fee_collector from Pool
    // itxn[1]: Transfer Asset 2 to fee_collector from Pool
    
    // bytes pool_address = Txn.Accounts[1] [slot 1]
    txna Accounts 1
    store 1 // pool_address
    // int asset_1_id = app_local_get(1, "asset_1_id") [slot 2]
    pushint 1
    pushbytes "asset_1_id"
    app_local_get
    store 2 // asset_1_id
    // int asset_2_id = app_local_get(1, "asset_2_id") [slot 3]
    pushint 1
    pushbytes "asset_2_id"
    app_local_get
    store 3 // asset_2_id
    
    // int asset_1_amount = get_balance(1, asset_1_id) - (app_local_get(1, "asset_1_reserves") + app_local_get(1, "asset_1_protocol_fees")) [slot 4]
    pushint 1
    load 2 // asset_1_id
    callsub __func__get_balance
    pushint 1
    pushbytes "asset_1_reserves"
    app_local_get
    pushint 1
    pushbytes "asset_1_protocol_fees"
    app_local_get
    +
    -
    store 4 // asset_1_amount
    // int asset_2_amount = get_balance(1, asset_2_id) - (app_local_get(1, "asset_2_reserves") + app_local_get(1, "asset_2_protocol_fees")) [slot 5]
    pushint 1
    load 3 // asset_2_id
    callsub __func__get_balance
    pushint 1
    pushbytes "asset_2_reserves"
    app_local_get
    pushint 1
    pushbytes "asset_2_protocol_fees"
    app_local_get
    +
    -
    store 5 // asset_2_amount
    
    // assert(asset_1_amount || asset_2_amount)
    load 4 // asset_1_amount
    load 5 // asset_2_amount
    ||
    assert
    // transfer(asset_1_id, asset_1_amount, pool_address, app_global_get("fee_collector"))
    load 2 // asset_1_id
    load 4 // asset_1_amount
    load 1 // pool_address
    pushbytes "fee_collector"
    app_global_get
    callsub __func__transfer
    // transfer(asset_2_id, asset_2_amount, pool_address, app_global_get("fee_collector"))
    load 3 // asset_2_id
    load 5 // asset_2_amount
    load 1 // pool_address
    pushbytes "fee_collector"
    app_global_get
    callsub __func__transfer
    // exit(1)
    pushint 1
    return
  
  // block set_fee
  main__set_fee:
    // Set a new fee collector, only fee setter can call this method
    // Txn: AppCall from fee_setter
    // assert(user_address == app_global_get("fee_setter"))
    load 0 // user_address
    pushbytes "fee_setter"
    app_global_get
    ==
    assert
    
    // int total_fee_share = btoi(Txn.ApplicationArgs[1]) [slot 1]
    txna ApplicationArgs 1
    btoi
    store 1 // total_fee_share
    // int protocol_fee_ratio = btoi(Txn.ApplicationArgs[2]) [slot 2]
    txna ApplicationArgs 2
    btoi
    store 2 // protocol_fee_ratio
    
    // assert(total_fee_share <= 100)
    load 1 // total_fee_share
    pushint 100
    <=
    assert
    // assert(total_fee_share >= 1)
    load 1 // total_fee_share
    pushint 1
    >=
    assert
    // assert(protocol_fee_ratio <= 10)
    load 2 // protocol_fee_ratio
    pushint 10
    <=
    assert
    // assert(protocol_fee_ratio >= 3)
    load 2 // protocol_fee_ratio
    pushint 3
    >=
    assert
    
    // State updates
    // [total_fee_share]
    // [protocol_fee_ratio]
    // app_local_put(1, "total_fee_share", total_fee_share)
    pushint 1
    pushbytes "total_fee_share"
    load 1 // total_fee_share
    app_local_put
    // app_local_put(1, "protocol_fee_ratio", protocol_fee_ratio)
    pushint 1
    pushbytes "protocol_fee_ratio"
    load 2 // protocol_fee_ratio
    app_local_put
    // exit(1)
    pushint 1
    return
  
  // block amm
  main__amm:
    // bytes pool_address = Txn.Accounts[1] [slot 1]
    txna Accounts 1
    store 1 // pool_address
    // These will fail if the account is not optted-in and only pool accounts can opt-in to the app.
    // int asset_1_id = app_local_get(1, "asset_1_id") [slot 2]
    pushint 1
    pushbytes "asset_1_id"
    app_local_get
    store 2 // asset_1_id
    // int asset_2_id = app_local_get(1, "asset_2_id") [slot 3]
    pushint 1
    pushbytes "asset_2_id"
    app_local_get
    store 3 // asset_2_id
    // int pool_token_asset_id = app_local_get(1, "pool_token_asset_id") [slot 4]
    pushint 1
    pushbytes "pool_token_asset_id"
    app_local_get
    store 4 // pool_token_asset_id
    // int asset_1_reserves = app_local_get(1, "asset_1_reserves") [slot 5]
    pushint 1
    pushbytes "asset_1_reserves"
    app_local_get
    store 5 // asset_1_reserves
    // int asset_2_reserves = app_local_get(1, "asset_2_reserves") [slot 6]
    pushint 1
    pushbytes "asset_2_reserves"
    app_local_get
    store 6 // asset_2_reserves
    // int issued_pool_tokens = app_local_get(1, "issued_pool_tokens") [slot 7]
    pushint 1
    pushbytes "issued_pool_tokens"
    app_local_get
    store 7 // issued_pool_tokens
    // int asset_1_protocol_fees = app_local_get(1, "asset_1_protocol_fees") [slot 8]
    pushint 1
    pushbytes "asset_1_protocol_fees"
    app_local_get
    store 8 // asset_1_protocol_fees
    // int asset_2_protocol_fees = app_local_get(1, "asset_2_protocol_fees") [slot 9]
    pushint 1
    pushbytes "asset_2_protocol_fees"
    app_local_get
    store 9 // asset_2_protocol_fees
    
    // assert((Txn.ApplicationArgs[0] == "verify_flash_swap") || (app_local_get(1, "lock") == 0))
    txna ApplicationArgs 0
    pushbytes "verify_flash_swap"
    ==
    pushint 1
    pushbytes "lock"
    app_local_get
    pushint 0
    ==
    ||
    assert
    
    // switch Txn.ApplicationArgs[0]:
    txna ApplicationArgs 0
    pushbytes "add_liquidity"
    ==
    bnz main__amm__add_liquidity
    txna ApplicationArgs 0
    pushbytes "remove_liquidity"
    ==
    bnz main__amm__remove_liquidity
    txna ApplicationArgs 0
    pushbytes "swap"
    ==
    bnz main__amm__swap
    txna ApplicationArgs 0
    pushbytes "flash_loan"
    ==
    bnz main__amm__flash_loan
    txna ApplicationArgs 0
    pushbytes "verify_flash_loan"
    ==
    bnz main__amm__verify_flash_loan
    txna ApplicationArgs 0
    pushbytes "flash_swap"
    ==
    bnz main__amm__flash_swap
    txna ApplicationArgs 0
    pushbytes "verify_flash_swap"
    ==
    bnz main__amm__verify_flash_swap
    err // unexpected value
    
    // block swap
    main__amm__swap:
      // update_price_oracle()
      callsub main__amm__func__update_price_oracle
      // Gtxn[N-1]: Transfer Asset1 to Pool from User
      // Gtxn[N]: AppCall from User
      // itxn[0]: Transfer Asset 2 to User from Pool
      
      // bytes k_initial = itob(asset_1_reserves) b* itob(asset_2_reserves) [slot 10]
      load 5 // asset_1_reserves
      itob
      load 6 // asset_2_reserves
      itob
      b*
      store 10 // k_initial
      // int input_txn_index = Txn.GroupIndex - 1 [slot 11]
      txn GroupIndex
      pushint 1
      -
      store 11 // input_txn_index
      // int min_output = btoi(Txn.ApplicationArgs[1]) [slot 12]
      txna ApplicationArgs 1
      btoi
      store 12 // min_output
      // bytes mode = Txn.ApplicationArgs[2] [slot 13]
      txna ApplicationArgs 2
      store 13 // mode
      // int input_asset_id [slot 14]
      // int output_asset_id [slot 15]
      // int input_amount [slot 16]
      
      // if Gtxn[input_txn_index].TypeEnum == Pay:
        load 11 // input_txn_index
        gtxns TypeEnum
        pushint 1 // Pay
        ==
        bz l3_elif_0
        // then:
          // assert(Gtxn[input_txn_index].Receiver == pool_address)
          load 11 // input_txn_index
          gtxns Receiver
          load 1 // pool_address
          ==
          assert
          // input_asset_id = 0
          pushint 0
          store 14 // input_asset_id
          // input_amount = Gtxn[input_txn_index].Amount
          load 11 // input_txn_index
          gtxns Amount
          store 16 // input_amount
        b l3_end
        l3_elif_0:
        // elif Gtxn[input_txn_index].TypeEnum == Axfer:
        load 11 // input_txn_index
        gtxns TypeEnum
        pushint 4 // Axfer
        ==
        bz l3_else
          // assert(Gtxn[input_txn_index].AssetReceiver == pool_address)
          load 11 // input_txn_index
          gtxns AssetReceiver
          load 1 // pool_address
          ==
          assert
          // input_asset_id = Gtxn[input_txn_index].XferAsset
          load 11 // input_txn_index
          gtxns XferAsset
          store 14 // input_asset_id
          // input_amount = Gtxn[input_txn_index].AssetAmount
          load 11 // input_txn_index
          gtxns AssetAmount
          store 16 // input_amount
        b l3_end
        l3_else:
        // else:
          // error()
          err
        l3_end: // end
      // assert(Gtxn[input_txn_index].Sender == user_address)
      load 11 // input_txn_index
      gtxns Sender
      load 0 // user_address
      ==
      assert
      
      // int input_supply [slot 17]
      // int output_supply [slot 18]
      // if input_asset_id == asset_1_id:
        load 14 // input_asset_id
        load 2 // asset_1_id
        ==
        bz l4_elif_0
        // then:
          // output_asset_id = asset_2_id
          load 3 // asset_2_id
          store 15 // output_asset_id
          // input_supply = asset_1_reserves
          load 5 // asset_1_reserves
          store 17 // input_supply
          // output_supply = asset_2_reserves
          load 6 // asset_2_reserves
          store 18 // output_supply
        b l4_end
        l4_elif_0:
        // elif input_asset_id == asset_2_id:
        load 14 // input_asset_id
        load 3 // asset_2_id
        ==
        bz l4_else
          // output_asset_id = asset_1_id
          load 2 // asset_1_id
          store 15 // output_asset_id
          // input_supply = asset_2_reserves
          load 6 // asset_2_reserves
          store 17 // input_supply
          // output_supply = asset_1_reserves
          load 5 // asset_1_reserves
          store 18 // output_supply
        b l4_end
        l4_else:
        // else:
          // error()
          err
        l4_end: // end
      
      // int total_fee_amount [slot 19]
      // int poolers_fee_amount [slot 20]
      // int protocol_fee_amount [slot 21]
      // int swap_amount [slot 22]
      // int output_amount [slot 23]
      // int change = 0 [slot 24]
      pushint 0
      store 24 // change
      // if mode == 'fixed-input':
        load 13 // mode
        pushbytes "fixed-input"
        ==
        bz l5_elif_0
        // then:
          // total_fee_amount, poolers_fee_amount, protocol_fee_amount = calculate_fixed_input_fee_amounts(input_amount)
          load 16 // input_amount
          callsub __func__calculate_fixed_input_fee_amounts
          store 19 // total_fee_amount
          store 20 // poolers_fee_amount
          store 21 // protocol_fee_amount
          // swap_amount = input_amount - total_fee_amount
          load 16 // input_amount
          load 19 // total_fee_amount
          -
          store 22 // swap_amount
          // output_amount = calculate_fixed_input_swap(input_supply, output_supply, swap_amount)
          load 17 // input_supply
          load 18 // output_supply
          load 22 // swap_amount
          callsub __func__calculate_fixed_input_swap
          store 23 // output_amount
          
          // assert(total_fee_amount, "If the amount is too small, total fee amount is rounded to 0.")
          load 19 // total_fee_amount
          assert // If the amount is too small, total fee amount is rounded to 0.
          // assert(output_amount >= min_output)
          load 23 // output_amount
          load 12 // min_output
          >=
          assert
        b l5_end
        l5_elif_0:
        // elif mode == 'fixed-output':
        load 13 // mode
        pushbytes "fixed-output"
        ==
        bz l5_else
          // output_amount = min_output
          load 12 // min_output
          store 23 // output_amount
          // swap_amount = calculate_fixed_output_swap(input_supply, output_supply, output_amount)
          load 17 // input_supply
          load 18 // output_supply
          load 23 // output_amount
          callsub __func__calculate_fixed_output_swap
          store 22 // swap_amount
          // total_fee_amount, poolers_fee_amount, protocol_fee_amount = calculate_fixed_output_fee_amounts(swap_amount)
          load 22 // swap_amount
          callsub __func__calculate_fixed_output_fee_amounts
          store 19 // total_fee_amount
          store 20 // poolers_fee_amount
          store 21 // protocol_fee_amount
          // int required_input_amount = swap_amount + total_fee_amount [slot 25]
          load 22 // swap_amount
          load 19 // total_fee_amount
          +
          store 25 // required_input_amount
          
          // assert(total_fee_amount, "If the amount is too small, total fee amount is rounded to 0.")
          load 19 // total_fee_amount
          assert // If the amount is too small, total fee amount is rounded to 0.
          // assert(input_amount >= required_input_amount)
          load 16 // input_amount
          load 25 // required_input_amount
          >=
          assert
          
          // change = input_amount - required_input_amount
          load 16 // input_amount
          load 25 // required_input_amount
          -
          store 24 // change
          // if change:
            load 24 // change
            bz l6_end
            // then:
              // transfer_to_user(input_asset_id, change)
              load 14 // input_asset_id
              load 24 // change
              callsub main__amm__func__transfer_to_user
            l6_end: // end
        b l5_end
        l5_else:
        // else:
          // error()
          err
        l5_end: // end
      
      // if input_asset_id == asset_1_id:
        load 14 // input_asset_id
        load 2 // asset_1_id
        ==
        bz l7_else
        // then:
          // asset_1_protocol_fees = asset_1_protocol_fees + protocol_fee_amount
          load 8 // asset_1_protocol_fees
          load 21 // protocol_fee_amount
          +
          store 8 // asset_1_protocol_fees
          // asset_1_reserves = asset_1_reserves + (swap_amount + poolers_fee_amount)
          load 5 // asset_1_reserves
          load 22 // swap_amount
          load 20 // poolers_fee_amount
          +
          +
          store 5 // asset_1_reserves
          // asset_2_reserves = asset_2_reserves - output_amount
          load 6 // asset_2_reserves
          load 23 // output_amount
          -
          store 6 // asset_2_reserves
        b l7_end
        l7_else:
        // else:
          // asset_2_protocol_fees = asset_2_protocol_fees + protocol_fee_amount
          load 9 // asset_2_protocol_fees
          load 21 // protocol_fee_amount
          +
          store 9 // asset_2_protocol_fees
          // asset_2_reserves = asset_2_reserves + (swap_amount + poolers_fee_amount)
          load 6 // asset_2_reserves
          load 22 // swap_amount
          load 20 // poolers_fee_amount
          +
          +
          store 6 // asset_2_reserves
          // asset_1_reserves = asset_1_reserves - output_amount
          load 5 // asset_1_reserves
          load 23 // output_amount
          -
          store 5 // asset_1_reserves
        l7_end: // end
      // assert(k_initial b< (itob(asset_1_reserves) b* itob(asset_2_reserves)), "Assert K<K'")
      load 10 // k_initial
      load 5 // asset_1_reserves
      itob
      load 6 // asset_2_reserves
      itob
      b*
      b<
      assert // Assert K<K'
      
      // transfer_to_user(output_asset_id, output_amount)
      load 15 // output_asset_id
      load 23 // output_amount
      callsub main__amm__func__transfer_to_user
      
      // Logs
      // log(concat("input_asset_id %i", itob(input_asset_id)))
      pushbytes "input_asset_id %i"
      load 14 // input_asset_id
      itob
      concat
      log
      // log(concat("input_amount %i", itob(input_amount)))
      pushbytes "input_amount %i"
      load 16 // input_amount
      itob
      concat
      log
      // log(concat("swap_amount %i", itob(swap_amount)))
      pushbytes "swap_amount %i"
      load 22 // swap_amount
      itob
      concat
      log
      // log(concat("change %i", itob(change)))
      pushbytes "change %i"
      load 24 // change
      itob
      concat
      log
      
      // log(concat("output_asset_id %i", itob(output_asset_id)))
      pushbytes "output_asset_id %i"
      load 15 // output_asset_id
      itob
      concat
      log
      // log(concat("output_amount %i", itob(output_amount)))
      pushbytes "output_amount %i"
      load 23 // output_amount
      itob
      concat
      log
      
      // log(concat("poolers_fee_amount %i", itob(poolers_fee_amount)))
      pushbytes "poolers_fee_amount %i"
      load 20 // poolers_fee_amount
      itob
      concat
      log
      // log(concat("protocol_fee_amount %i", itob(protocol_fee_amount)))
      pushbytes "protocol_fee_amount %i"
      load 21 // protocol_fee_amount
      itob
      concat
      log
      // log(concat("total_fee_amount %i", itob(total_fee_amount)))
      pushbytes "total_fee_amount %i"
      load 19 // total_fee_amount
      itob
      concat
      log
      
      // State updates
      // app_local_put(1, "asset_1_reserves", asset_1_reserves)
      pushint 1
      pushbytes "asset_1_reserves"
      load 5 // asset_1_reserves
      app_local_put
      // app_local_put(1, "asset_2_reserves", asset_2_reserves)
      pushint 1
      pushbytes "asset_2_reserves"
      load 6 // asset_2_reserves
      app_local_put
      // app_local_put(1, "asset_1_protocol_fees", asset_1_protocol_fees)
      pushint 1
      pushbytes "asset_1_protocol_fees"
      load 8 // asset_1_protocol_fees
      app_local_put
      // app_local_put(1, "asset_2_protocol_fees", asset_2_protocol_fees)
      pushint 1
      pushbytes "asset_2_protocol_fees"
      load 9 // asset_2_protocol_fees
      app_local_put
      // exit(1)
      pushint 1
      return
    
    // block flash_loan
    main__amm__flash_loan:
      // update_price_oracle()
      callsub main__amm__func__update_price_oracle
      // Gtxn[N]: Flash Loan AppCall from User
      // itxn: Transfer Asset 1 to User from Pool if Asset 1 is requested
      // itxn: Transfer Asset 2 to User from Pool if Asset 2 is requested
      
      // Gtxn[N+X]: Verify Flash Loan AppCall from User
      
      // int index_diff = btoi(Txn.ApplicationArgs[1]) [slot 10]
      txna ApplicationArgs 1
      btoi
      store 10 // index_diff
      // int verify_flash_loan_txn_index = Txn.GroupIndex + index_diff [slot 11]
      txn GroupIndex
      load 10 // index_diff
      +
      store 11 // verify_flash_loan_txn_index
      // assert(Gtxn[verify_flash_loan_txn_index].TypeEnum == Appl)
      load 11 // verify_flash_loan_txn_index
      gtxns TypeEnum
      pushint 6 // Appl
      ==
      assert
      // assert(Gtxn[verify_flash_loan_txn_index].ApplicationID == Global.CurrentApplicationID)
      load 11 // verify_flash_loan_txn_index
      gtxns ApplicationID
      global CurrentApplicationID
      ==
      assert
      // assert(Gtxn[verify_flash_loan_txn_index].ApplicationArgs[0] == "verify_flash_loan")
      load 11 // verify_flash_loan_txn_index
      gtxnsa ApplicationArgs 0
      pushbytes "verify_flash_loan"
      ==
      assert
      // assert(Gtxn[verify_flash_loan_txn_index].ApplicationArgs[1] == Txn.ApplicationArgs[1], "index_diff")
      load 11 // verify_flash_loan_txn_index
      gtxnsa ApplicationArgs 1
      txna ApplicationArgs 1
      ==
      assert // index_diff
      // assert(Gtxn[verify_flash_loan_txn_index].Sender == user_address)
      load 11 // verify_flash_loan_txn_index
      gtxns Sender
      load 0 // user_address
      ==
      assert
      // int asset_1_amount = btoi(Txn.ApplicationArgs[2]) [slot 12]
      txna ApplicationArgs 2
      btoi
      store 12 // asset_1_amount
      // int asset_2_amount = btoi(Txn.ApplicationArgs[3]) [slot 13]
      txna ApplicationArgs 3
      btoi
      store 13 // asset_2_amount
      // assert(asset_1_amount || asset_2_amount)
      load 12 // asset_1_amount
      load 13 // asset_2_amount
      ||
      assert
      
      // if asset_1_amount:
        load 12 // asset_1_amount
        bz l8_end
        // then:
          // assert(asset_1_amount <= asset_1_reserves)
          load 12 // asset_1_amount
          load 5 // asset_1_reserves
          <=
          assert
          // transfer_to_user(asset_1_id, asset_1_amount)
          load 2 // asset_1_id
          load 12 // asset_1_amount
          callsub main__amm__func__transfer_to_user
        l8_end: // end
      // if asset_2_amount:
        load 13 // asset_2_amount
        bz l9_end
        // then:
          // assert(asset_2_amount <= asset_2_reserves)
          load 13 // asset_2_amount
          load 6 // asset_2_reserves
          <=
          assert
          // transfer_to_user(asset_2_id, asset_2_amount)
          load 3 // asset_2_id
          load 13 // asset_2_amount
          callsub main__amm__func__transfer_to_user
        l9_end: // end
      // exit(1)
      pushint 1
      return
    
    // block verify_flash_loan
    main__amm__verify_flash_loan:
      // Gtxn[N-X]: Flash Loan AppCall from User
      
      // if borrowed in two assets:
      // Gtxn[N-2]: Transfer Asset 1 to Pool
      // Gtxn[N-1]: Transfer Asset 2 to Pool
      // if borrowed single asset:
      // Gtxn[N-1]: Transfer borrowed Asset to Pool
      // Gtxn[N]: Verify Flash Loan AppCall from User
      
      // int index_diff = btoi(Txn.ApplicationArgs[1]) [slot 10]
      txna ApplicationArgs 1
      btoi
      store 10 // index_diff
      // int flash_loan_txn_index = Txn.GroupIndex - index_diff [slot 11]
      txn GroupIndex
      load 10 // index_diff
      -
      store 11 // flash_loan_txn_index
      // assert(Gtxn[flash_loan_txn_index].TypeEnum == Appl)
      load 11 // flash_loan_txn_index
      gtxns TypeEnum
      pushint 6 // Appl
      ==
      assert
      // assert(Gtxn[flash_loan_txn_index].ApplicationID == Global.CurrentApplicationID)
      load 11 // flash_loan_txn_index
      gtxns ApplicationID
      global CurrentApplicationID
      ==
      assert
      // assert(Gtxn[flash_loan_txn_index].ApplicationArgs[0] == "flash_loan")
      load 11 // flash_loan_txn_index
      gtxnsa ApplicationArgs 0
      pushbytes "flash_loan"
      ==
      assert
      // assert(Gtxn[flash_loan_txn_index].ApplicationArgs[1] == Txn.ApplicationArgs[1], "index_diff")
      load 11 // flash_loan_txn_index
      gtxnsa ApplicationArgs 1
      txna ApplicationArgs 1
      ==
      assert // index_diff
      // assert(Gtxn[flash_loan_txn_index].Sender == user_address)
      load 11 // flash_loan_txn_index
      gtxns Sender
      load 0 // user_address
      ==
      assert
      // int asset_1_output_amount = btoi(Gtxn[flash_loan_txn_index].ApplicationArgs[2]) [slot 12]
      load 11 // flash_loan_txn_index
      gtxnsa ApplicationArgs 2
      btoi
      store 12 // asset_1_output_amount
      // int asset_2_output_amount = btoi(Gtxn[flash_loan_txn_index].ApplicationArgs[3]) [slot 13]
      load 11 // flash_loan_txn_index
      gtxnsa ApplicationArgs 3
      btoi
      store 13 // asset_2_output_amount
      
      // if asset_1_output_amount:
        load 12 // asset_1_output_amount
        bz l10_end
        // then:
          // int asset_1_total_fee_amount [slot 14]
          // int asset_1_poolers_fee_amount [slot 15]
          // int asset_1_protocol_fee_amount [slot 16]
          // int asset_1_repayment_amount [slot 17]
          
          // asset_1_total_fee_amount, asset_1_poolers_fee_amount, asset_1_protocol_fee_amount = calculate_fixed_input_fee_amounts(asset_1_output_amount)
          load 12 // asset_1_output_amount
          callsub __func__calculate_fixed_input_fee_amounts
          store 14 // asset_1_total_fee_amount
          store 15 // asset_1_poolers_fee_amount
          store 16 // asset_1_protocol_fee_amount
          // asset_1_repayment_amount = asset_1_output_amount + asset_1_total_fee_amount
          load 12 // asset_1_output_amount
          load 14 // asset_1_total_fee_amount
          +
          store 17 // asset_1_repayment_amount
          // assert(asset_1_repayment_amount > asset_1_output_amount)
          load 17 // asset_1_repayment_amount
          load 12 // asset_1_output_amount
          >
          assert
          
          // int asset_1_txn_index [slot 18]
          // if asset_2_output_amount:
            load 13 // asset_2_output_amount
            bz l11_else
            // then:
              // asset_1_txn_index = Txn.GroupIndex - 2
              txn GroupIndex
              pushint 2
              -
              store 18 // asset_1_txn_index
            b l11_end
            l11_else:
            // else:
              // asset_1_txn_index = Txn.GroupIndex - 1
              txn GroupIndex
              pushint 1
              -
              store 18 // asset_1_txn_index
            l11_end: // end
          
          // assert(Gtxn[asset_1_txn_index].TypeEnum == Axfer)
          load 18 // asset_1_txn_index
          gtxns TypeEnum
          pushint 4 // Axfer
          ==
          assert
          // assert(Gtxn[asset_1_txn_index].XferAsset == asset_1_id)
          load 18 // asset_1_txn_index
          gtxns XferAsset
          load 2 // asset_1_id
          ==
          assert
          // assert(Gtxn[asset_1_txn_index].Sender == user_address)
          load 18 // asset_1_txn_index
          gtxns Sender
          load 0 // user_address
          ==
          assert
          // assert(Gtxn[asset_1_txn_index].AssetReceiver == pool_address)
          load 18 // asset_1_txn_index
          gtxns AssetReceiver
          load 1 // pool_address
          ==
          assert
          // assert(Gtxn[asset_1_txn_index].AssetAmount >= asset_1_repayment_amount)
          load 18 // asset_1_txn_index
          gtxns AssetAmount
          load 17 // asset_1_repayment_amount
          >=
          assert
          // int asset_1_input_amount = Gtxn[asset_1_txn_index].AssetAmount [slot 19]
          load 18 // asset_1_txn_index
          gtxns AssetAmount
          store 19 // asset_1_input_amount
          // int asset_1_donation_amount = asset_1_input_amount - asset_1_repayment_amount [slot 20]
          load 19 // asset_1_input_amount
          load 17 // asset_1_repayment_amount
          -
          store 20 // asset_1_donation_amount
          
          // asset_1_protocol_fees = asset_1_protocol_fees + asset_1_protocol_fee_amount
          load 8 // asset_1_protocol_fees
          load 16 // asset_1_protocol_fee_amount
          +
          store 8 // asset_1_protocol_fees
          // asset_1_reserves = asset_1_reserves + asset_1_poolers_fee_amount
          load 5 // asset_1_reserves
          load 15 // asset_1_poolers_fee_amount
          +
          store 5 // asset_1_reserves
          
          // Logs
          // log(concat("asset_1_output_amount %i", itob(asset_1_output_amount)))
          pushbytes "asset_1_output_amount %i"
          load 12 // asset_1_output_amount
          itob
          concat
          log
          // log(concat("asset_1_input_amount %i", itob(asset_1_input_amount)))
          pushbytes "asset_1_input_amount %i"
          load 19 // asset_1_input_amount
          itob
          concat
          log
          // log(concat("asset_1_donation_amount %i", itob(asset_1_donation_amount)))
          pushbytes "asset_1_donation_amount %i"
          load 20 // asset_1_donation_amount
          itob
          concat
          log
          // log(concat("asset_1_poolers_fee_amount %i", itob(asset_1_poolers_fee_amount)))
          pushbytes "asset_1_poolers_fee_amount %i"
          load 15 // asset_1_poolers_fee_amount
          itob
          concat
          log
          // log(concat("asset_1_protocol_fee_amount %i", itob(asset_1_protocol_fee_amount)))
          pushbytes "asset_1_protocol_fee_amount %i"
          load 16 // asset_1_protocol_fee_amount
          itob
          concat
          log
          // log(concat("asset_1_total_fee_amount %i", itob(asset_1_total_fee_amount)))
          pushbytes "asset_1_total_fee_amount %i"
          load 14 // asset_1_total_fee_amount
          itob
          concat
          log
        l10_end: // end
      
      // if asset_2_output_amount:
        load 13 // asset_2_output_amount
        bz l12_end
        // then:
          // int asset_2_total_fee_amount [slot 21]
          // int asset_2_poolers_fee_amount [slot 22]
          // int asset_2_protocol_fee_amount [slot 23]
          // int asset_2_repayment_amount [slot 24]
          
          // asset_2_total_fee_amount, asset_2_poolers_fee_amount, asset_2_protocol_fee_amount = calculate_fixed_input_fee_amounts(asset_2_output_amount)
          load 13 // asset_2_output_amount
          callsub __func__calculate_fixed_input_fee_amounts
          store 21 // asset_2_total_fee_amount
          store 22 // asset_2_poolers_fee_amount
          store 23 // asset_2_protocol_fee_amount
          // asset_2_repayment_amount = asset_2_output_amount + asset_2_total_fee_amount
          load 13 // asset_2_output_amount
          load 21 // asset_2_total_fee_amount
          +
          store 24 // asset_2_repayment_amount
          // assert(asset_2_repayment_amount > asset_2_output_amount)
          load 24 // asset_2_repayment_amount
          load 13 // asset_2_output_amount
          >
          assert
          
          // int asset_2_txn_index = Txn.GroupIndex - 1 [slot 25]
          txn GroupIndex
          pushint 1
          -
          store 25 // asset_2_txn_index
          // int asset_2_input_amount [slot 26]
          // int asset_2_donation_amount [slot 27]
          // if asset_2_id == 0:
            load 3 // asset_2_id
            pushint 0
            ==
            bz l13_else
            // then:
              // assert(Gtxn[asset_2_txn_index].TypeEnum == Pay)
              load 25 // asset_2_txn_index
              gtxns TypeEnum
              pushint 1 // Pay
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].Sender == user_address)
              load 25 // asset_2_txn_index
              gtxns Sender
              load 0 // user_address
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].Receiver == pool_address)
              load 25 // asset_2_txn_index
              gtxns Receiver
              load 1 // pool_address
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].Amount >= asset_2_repayment_amount)
              load 25 // asset_2_txn_index
              gtxns Amount
              load 24 // asset_2_repayment_amount
              >=
              assert
              // asset_2_input_amount = Gtxn[asset_2_txn_index].Amount
              load 25 // asset_2_txn_index
              gtxns Amount
              store 26 // asset_2_input_amount
            b l13_end
            l13_else:
            // else:
              // assert(Gtxn[asset_2_txn_index].TypeEnum == Axfer)
              load 25 // asset_2_txn_index
              gtxns TypeEnum
              pushint 4 // Axfer
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].XferAsset == asset_2_id)
              load 25 // asset_2_txn_index
              gtxns XferAsset
              load 3 // asset_2_id
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].Sender == user_address)
              load 25 // asset_2_txn_index
              gtxns Sender
              load 0 // user_address
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].AssetReceiver == pool_address)
              load 25 // asset_2_txn_index
              gtxns AssetReceiver
              load 1 // pool_address
              ==
              assert
              // assert(Gtxn[asset_2_txn_index].AssetAmount >= asset_2_repayment_amount)
              load 25 // asset_2_txn_index
              gtxns AssetAmount
              load 24 // asset_2_repayment_amount
              >=
              assert
              // asset_2_input_amount = Gtxn[asset_2_txn_index].AssetAmount
              load 25 // asset_2_txn_index
              gtxns AssetAmount
              store 26 // asset_2_input_amount
            l13_end: // end
          
          // asset_2_donation_amount = asset_2_input_amount - asset_2_repayment_amount
          load 26 // asset_2_input_amount
          load 24 // asset_2_repayment_amount
          -
          store 27 // asset_2_donation_amount
          // asset_2_protocol_fees = asset_2_protocol_fees + asset_2_protocol_fee_amount
          load 9 // asset_2_protocol_fees
          load 23 // asset_2_protocol_fee_amount
          +
          store 9 // asset_2_protocol_fees
          // asset_2_reserves = asset_2_reserves + asset_2_poolers_fee_amount
          load 6 // asset_2_reserves
          load 22 // asset_2_poolers_fee_amount
          +
          store 6 // asset_2_reserves
          
          // Logs
          // log(concat("asset_2_output_amount %i", itob(asset_2_output_amount)))
          pushbytes "asset_2_output_amount %i"
          load 13 // asset_2_output_amount
          itob
          concat
          log
          // log(concat("asset_2_input_amount %i", itob(asset_2_input_amount)))
          pushbytes "asset_2_input_amount %i"
          load 26 // asset_2_input_amount
          itob
          concat
          log
          // log(concat("asset_2_donation_amount %i", itob(asset_2_donation_amount)))
          pushbytes "asset_2_donation_amount %i"
          load 27 // asset_2_donation_amount
          itob
          concat
          log
          // log(concat("asset_2_poolers_fee_amount %i", itob(asset_2_poolers_fee_amount)))
          pushbytes "asset_2_poolers_fee_amount %i"
          load 22 // asset_2_poolers_fee_amount
          itob
          concat
          log
          // log(concat("asset_2_protocol_fee_amount %i", itob(asset_2_protocol_fee_amount)))
          pushbytes "asset_2_protocol_fee_amount %i"
          load 23 // asset_2_protocol_fee_amount
          itob
          concat
          log
          // log(concat("asset_2_total_fee_amount %i", itob(asset_2_total_fee_amount)))
          pushbytes "asset_2_total_fee_amount %i"
          load 21 // asset_2_total_fee_amount
          itob
          concat
          log
        l12_end: // end
      
      // State updates
      // app_local_put(1, "asset_1_reserves", asset_1_reserves)
      pushint 1
      pushbytes "asset_1_reserves"
      load 5 // asset_1_reserves
      app_local_put
      // app_local_put(1, "asset_2_reserves", asset_2_reserves)
      pushint 1
      pushbytes "asset_2_reserves"
      load 6 // asset_2_reserves
      app_local_put
      // app_local_put(1, "asset_1_protocol_fees", asset_1_protocol_fees)
      pushint 1
      pushbytes "asset_1_protocol_fees"
      load 8 // asset_1_protocol_fees
      app_local_put
      // app_local_put(1, "asset_2_protocol_fees", asset_2_protocol_fees)
      pushint 1
      pushbytes "asset_2_protocol_fees"
      load 9 // asset_2_protocol_fees
      app_local_put
      // exit(1)
      pushint 1
      return
    
    // block flash_swap
    main__amm__flash_swap:
      // app_local_put(1, "lock", 1)
      pushint 1
      pushbytes "lock"
      pushint 1
      app_local_put
      // update_price_oracle()
      callsub main__amm__func__update_price_oracle
      // Gtxn[N]: Flash Swap AppCall from User
      // itxn: Transfer Asset 1 to User from Pool if Asset 1 is requested
      // itxn: Transfer Asset 2 to User from Pool if Asset 2 is requested
      
      // Gtxn[N+X]: Verify Flash Swap AppCall from User
      
      // int index_diff = btoi(Txn.ApplicationArgs[1]) [slot 10]
      txna ApplicationArgs 1
      btoi
      store 10 // index_diff
      // int verify_flash_swap_txn_index = Txn.GroupIndex + index_diff [slot 11]
      txn GroupIndex
      load 10 // index_diff
      +
      store 11 // verify_flash_swap_txn_index
      // assert(Gtxn[verify_flash_swap_txn_index].TypeEnum == Appl)
      load 11 // verify_flash_swap_txn_index
      gtxns TypeEnum
      pushint 6 // Appl
      ==
      assert
      // assert(Gtxn[verify_flash_swap_txn_index].ApplicationID == Global.CurrentApplicationID)
      load 11 // verify_flash_swap_txn_index
      gtxns ApplicationID
      global CurrentApplicationID
      ==
      assert
      // assert(Gtxn[verify_flash_swap_txn_index].ApplicationArgs[0] == "verify_flash_swap")
      load 11 // verify_flash_swap_txn_index
      gtxnsa ApplicationArgs 0
      pushbytes "verify_flash_swap"
      ==
      assert
      // assert(Gtxn[verify_flash_swap_txn_index].ApplicationArgs[1] == Txn.ApplicationArgs[1], "index_diff")
      load 11 // verify_flash_swap_txn_index
      gtxnsa ApplicationArgs 1
      txna ApplicationArgs 1
      ==
      assert // index_diff
      // assert(Gtxn[verify_flash_swap_txn_index].Sender == user_address)
      load 11 // verify_flash_swap_txn_index
      gtxns Sender
      load 0 // user_address
      ==
      assert
      // int asset_1_output_amount = btoi(Txn.ApplicationArgs[2]) [slot 12]
      txna ApplicationArgs 2
      btoi
      store 12 // asset_1_output_amount
      // int asset_2_output_amount = btoi(Txn.ApplicationArgs[3]) [slot 13]
      txna ApplicationArgs 3
      btoi
      store 13 // asset_2_output_amount
      // assert(asset_1_output_amount || asset_2_output_amount)
      load 12 // asset_1_output_amount
      load 13 // asset_2_output_amount
      ||
      assert
      
      // if asset_1_output_amount:
        load 12 // asset_1_output_amount
        bz l14_end
        // then:
          // transfer_to_user(asset_1_id, asset_1_output_amount)
          load 2 // asset_1_id
          load 12 // asset_1_output_amount
          callsub main__amm__func__transfer_to_user
        l14_end: // end
      // if asset_2_output_amount:
        load 13 // asset_2_output_amount
        bz l15_end
        // then:
          // transfer_to_user(asset_2_id, asset_2_output_amount)
          load 3 // asset_2_id
          load 13 // asset_2_output_amount
          callsub main__amm__func__transfer_to_user
        l15_end: // end
      
      // Share data between app calls
      // initial_k
      // log(itob(asset_1_reserves) b* itob(asset_2_reserves))
      load 5 // asset_1_reserves
      itob
      load 6 // asset_2_reserves
      itob
      b*
      log
      // asset_1_balance_after_transfer
      // log(itob(get_balance(1, asset_1_id)))
      pushint 1
      load 2 // asset_1_id
      callsub __func__get_balance
      itob
      log
      // asset_2_balance_after_transfer
      // log(itob(get_balance(1, asset_2_id)))
      pushint 1
      load 3 // asset_2_id
      callsub __func__get_balance
      itob
      log
      // exit(1)
      pushint 1
      return
    
    // block verify_flash_swap
    main__amm__verify_flash_swap:
      // Gtxn[N-X]: Flash Swap AppCall from User
      // Gtxn[N]: Verify Flash Swap AppCall from User
      
      // int index_diff = btoi(Txn.ApplicationArgs[1]) [slot 10]
      txna ApplicationArgs 1
      btoi
      store 10 // index_diff
      // int flash_swap_txn_index = Txn.GroupIndex - index_diff [slot 11]
      txn GroupIndex
      load 10 // index_diff
      -
      store 11 // flash_swap_txn_index
      // assert(Gtxn[flash_swap_txn_index].TypeEnum == Appl)
      load 11 // flash_swap_txn_index
      gtxns TypeEnum
      pushint 6 // Appl
      ==
      assert
      // assert(Gtxn[flash_swap_txn_index].ApplicationID == Global.CurrentApplicationID)
      load 11 // flash_swap_txn_index
      gtxns ApplicationID
      global CurrentApplicationID
      ==
      assert
      // assert(Gtxn[flash_swap_txn_index].ApplicationArgs[0] == "flash_swap")
      load 11 // flash_swap_txn_index
      gtxnsa ApplicationArgs 0
      pushbytes "flash_swap"
      ==
      assert
      // assert(Gtxn[flash_swap_txn_index].ApplicationArgs[1] == Txn.ApplicationArgs[1], "index_diff")
      load 11 // flash_swap_txn_index
      gtxnsa ApplicationArgs 1
      txna ApplicationArgs 1
      ==
      assert // index_diff
      // int asset_1_output_amount = btoi(Gtxn[flash_swap_txn_index].ApplicationArgs[2]) [slot 12]
      load 11 // flash_swap_txn_index
      gtxnsa ApplicationArgs 2
      btoi
      store 12 // asset_1_output_amount
      // int asset_2_output_amount = btoi(Gtxn[flash_swap_txn_index].ApplicationArgs[3]) [slot 13]
      load 11 // flash_swap_txn_index
      gtxnsa ApplicationArgs 3
      btoi
      store 13 // asset_2_output_amount
      
      // bytes initial_k = Gtxn[flash_swap_txn_index].Logs[0] [slot 14]
      load 11 // flash_swap_txn_index
      gtxnsa Logs 0
      store 14 // initial_k
      // int asset_1_balance_after_transfer = btoi(Gtxn[flash_swap_txn_index].Logs[1]) [slot 15]
      load 11 // flash_swap_txn_index
      gtxnsa Logs 1
      btoi
      store 15 // asset_1_balance_after_transfer
      // int asset_2_balance_after_transfer = btoi(Gtxn[flash_swap_txn_index].Logs[2]) [slot 16]
      load 11 // flash_swap_txn_index
      gtxnsa Logs 2
      btoi
      store 16 // asset_2_balance_after_transfer
      // int asset_1_balance = get_balance(1, asset_1_id) [slot 17]
      pushint 1
      load 2 // asset_1_id
      callsub __func__get_balance
      store 17 // asset_1_balance
      // int asset_2_balance = get_balance(1, asset_2_id) [slot 18]
      pushint 1
      load 3 // asset_2_id
      callsub __func__get_balance
      store 18 // asset_2_balance
      
      // int asset_1_input_amount = 0 [slot 19]
      pushint 0
      store 19 // asset_1_input_amount
      // if asset_1_balance > asset_1_balance_after_transfer:
        load 17 // asset_1_balance
        load 15 // asset_1_balance_after_transfer
        >
        bz l16_end
        // then:
          // asset_1_input_amount = asset_1_balance - asset_1_balance_after_transfer
          load 17 // asset_1_balance
          load 15 // asset_1_balance_after_transfer
          -
          store 19 // asset_1_input_amount
        l16_end: // end
      
      // int asset_2_input_amount = 0 [slot 20]
      pushint 0
      store 20 // asset_2_input_amount
      // if asset_2_balance > asset_2_balance_after_transfer:
        load 18 // asset_2_balance
        load 16 // asset_2_balance_after_transfer
        >
        bz l17_end
        // then:
          // asset_2_input_amount = asset_2_balance - asset_2_balance_after_transfer
          load 18 // asset_2_balance
          load 16 // asset_2_balance_after_transfer
          -
          store 20 // asset_2_input_amount
        l17_end: // end
      
      // int asset_1_total_fee_amount = 0 [slot 21]
      pushint 0
      store 21 // asset_1_total_fee_amount
      // int asset_1_poolers_fee_amount = 0 [slot 22]
      pushint 0
      store 22 // asset_1_poolers_fee_amount
      // int asset_1_protocol_fee_amount = 0 [slot 23]
      pushint 0
      store 23 // asset_1_protocol_fee_amount
      // if asset_1_input_amount:
        load 19 // asset_1_input_amount
        bz l18_else
        // then:
          // asset_1_total_fee_amount, asset_1_poolers_fee_amount, asset_1_protocol_fee_amount = calculate_fixed_input_fee_amounts(asset_1_input_amount)
          load 19 // asset_1_input_amount
          callsub __func__calculate_fixed_input_fee_amounts
          store 21 // asset_1_total_fee_amount
          store 22 // asset_1_poolers_fee_amount
          store 23 // asset_1_protocol_fee_amount
          // asset_1_protocol_fees = asset_1_protocol_fees + asset_1_protocol_fee_amount
          load 8 // asset_1_protocol_fees
          load 23 // asset_1_protocol_fee_amount
          +
          store 8 // asset_1_protocol_fees
          // asset_1_reserves = (asset_1_reserves - asset_1_output_amount) + (asset_1_input_amount - asset_1_protocol_fee_amount)
          load 5 // asset_1_reserves
          load 12 // asset_1_output_amount
          -
          load 19 // asset_1_input_amount
          load 23 // asset_1_protocol_fee_amount
          -
          +
          store 5 // asset_1_reserves
        b l18_end
        l18_else:
        // else:
          // asset_1_reserves = asset_1_reserves - asset_1_output_amount
          load 5 // asset_1_reserves
          load 12 // asset_1_output_amount
          -
          store 5 // asset_1_reserves
        l18_end: // end
      
      // int asset_2_total_fee_amount = 0 [slot 24]
      pushint 0
      store 24 // asset_2_total_fee_amount
      // int asset_2_poolers_fee_amount = 0 [slot 25]
      pushint 0
      store 25 // asset_2_poolers_fee_amount
      // int asset_2_protocol_fee_amount = 0 [slot 26]
      pushint 0
      store 26 // asset_2_protocol_fee_amount
      // if asset_2_input_amount:
        load 20 // asset_2_input_amount
        bz l19_else
        // then:
          // asset_2_total_fee_amount, asset_2_poolers_fee_amount, asset_2_protocol_fee_amount = calculate_fixed_input_fee_amounts(asset_2_input_amount)
          load 20 // asset_2_input_amount
          callsub __func__calculate_fixed_input_fee_amounts
          store 24 // asset_2_total_fee_amount
          store 25 // asset_2_poolers_fee_amount
          store 26 // asset_2_protocol_fee_amount
          // asset_2_protocol_fees = asset_2_protocol_fees + asset_2_protocol_fee_amount
          load 9 // asset_2_protocol_fees
          load 26 // asset_2_protocol_fee_amount
          +
          store 9 // asset_2_protocol_fees
          // asset_2_reserves = (asset_2_reserves - asset_2_output_amount) + (asset_2_input_amount - asset_2_protocol_fee_amount)
          load 6 // asset_2_reserves
          load 13 // asset_2_output_amount
          -
          load 20 // asset_2_input_amount
          load 26 // asset_2_protocol_fee_amount
          -
          +
          store 6 // asset_2_reserves
        b l19_end
        l19_else:
        // else:
          // asset_2_reserves = asset_2_reserves - asset_2_output_amount
          load 6 // asset_2_reserves
          load 13 // asset_2_output_amount
          -
          store 6 // asset_2_reserves
        l19_end: // end
      
      // assert(initial_k b< (itob(asset_1_reserves - asset_1_poolers_fee_amount) b* itob(asset_2_reserves - asset_2_poolers_fee_amount)), "Initial K < New K")
      load 14 // initial_k
      load 5 // asset_1_reserves
      load 22 // asset_1_poolers_fee_amount
      -
      itob
      load 6 // asset_2_reserves
      load 25 // asset_2_poolers_fee_amount
      -
      itob
      b*
      b<
      assert // Initial K < New K
      
      // Logs
      // log(concat("asset_1_output_amount %i", itob(asset_1_output_amount)))
      pushbytes "asset_1_output_amount %i"
      load 12 // asset_1_output_amount
      itob
      concat
      log
      // log(concat("asset_1_input_amount %i", itob(asset_1_input_amount)))
      pushbytes "asset_1_input_amount %i"
      load 19 // asset_1_input_amount
      itob
      concat
      log
      // log(concat("asset_1_poolers_fee_amount %i", itob(asset_1_poolers_fee_amount)))
      pushbytes "asset_1_poolers_fee_amount %i"
      load 22 // asset_1_poolers_fee_amount
      itob
      concat
      log
      // log(concat("asset_1_protocol_fee_amount %i", itob(asset_1_protocol_fee_amount)))
      pushbytes "asset_1_protocol_fee_amount %i"
      load 23 // asset_1_protocol_fee_amount
      itob
      concat
      log
      // log(concat("asset_1_total_fee_amount %i", itob(asset_1_total_fee_amount)))
      pushbytes "asset_1_total_fee_amount %i"
      load 21 // asset_1_total_fee_amount
      itob
      concat
      log
      
      // log(concat("asset_2_output_amount %i", itob(asset_2_output_amount)))
      pushbytes "asset_2_output_amount %i"
      load 13 // asset_2_output_amount
      itob
      concat
      log
      // log(concat("asset_2_input_amount %i", itob(asset_2_input_amount)))
      pushbytes "asset_2_input_amount %i"
      load 20 // asset_2_input_amount
      itob
      concat
      log
      // log(concat("asset_2_poolers_fee_amount %i", itob(asset_2_poolers_fee_amount)))
      pushbytes "asset_2_poolers_fee_amount %i"
      load 25 // asset_2_poolers_fee_amount
      itob
      concat
      log
      // log(concat("asset_2_protocol_fee_amount %i", itob(asset_2_protocol_fee_amount)))
      pushbytes "asset_2_protocol_fee_amount %i"
      load 26 // asset_2_protocol_fee_amount
      itob
      concat
      log
      // log(concat("asset_2_total_fee_amount %i", itob(asset_2_total_fee_amount)))
      pushbytes "asset_2_total_fee_amount %i"
      load 24 // asset_2_total_fee_amount
      itob
      concat
      log
      
      // State updates
      // app_local_put(1, "lock", 0)
      pushint 1
      pushbytes "lock"
      pushint 0
      app_local_put
      // app_local_put(1, "asset_1_reserves", asset_1_reserves)
      pushint 1
      pushbytes "asset_1_reserves"
      load 5 // asset_1_reserves
      app_local_put
      // app_local_put(1, "asset_2_reserves", asset_2_reserves)
      pushint 1
      pushbytes "asset_2_reserves"
      load 6 // asset_2_reserves
      app_local_put
      // app_local_put(1, "asset_1_protocol_fees", asset_1_protocol_fees)
      pushint 1
      pushbytes "asset_1_protocol_fees"
      load 8 // asset_1_protocol_fees
      app_local_put
      // app_local_put(1, "asset_2_protocol_fees", asset_2_protocol_fees)
      pushint 1
      pushbytes "asset_2_protocol_fees"
      load 9 // asset_2_protocol_fees
      app_local_put
      // exit(1)
      pushint 1
      return
    
    // block add_liquidity
    main__amm__add_liquidity:
      // Gtxn[N-2]: Transfer Asset1 to Pool from User
      // Gtxn[N-1]: Transfer Asset2 to Pool from User
      // Gtxn[N]: AppCall from User
      // itxn[0]: Transfer Pool Token to User from Pool
      // itxn[1]: Transfer Asset 1 or 2 to User from Pool (change)
      
      // int asset_1_txn_index = Txn.GroupIndex - 2 [slot 10]
      txn GroupIndex
      pushint 2
      -
      store 10 // asset_1_txn_index
      // int asset_2_txn_index = Txn.GroupIndex - 1 [slot 11]
      txn GroupIndex
      pushint 1
      -
      store 11 // asset_2_txn_index
      
      // assert(Gtxn[asset_1_txn_index].TypeEnum == Axfer)
      load 10 // asset_1_txn_index
      gtxns TypeEnum
      pushint 4 // Axfer
      ==
      assert
      // assert(Gtxn[asset_1_txn_index].AssetReceiver == pool_address)
      load 10 // asset_1_txn_index
      gtxns AssetReceiver
      load 1 // pool_address
      ==
      assert
      // assert(Gtxn[asset_1_txn_index].XferAsset == asset_1_id)
      load 10 // asset_1_txn_index
      gtxns XferAsset
      load 2 // asset_1_id
      ==
      assert
      // assert(Gtxn[asset_1_txn_index].Sender == user_address)
      load 10 // asset_1_txn_index
      gtxns Sender
      load 0 // user_address
      ==
      assert
      // int asset_1_amount = Gtxn[asset_1_txn_index].AssetAmount [slot 12]
      load 10 // asset_1_txn_index
      gtxns AssetAmount
      store 12 // asset_1_amount
      
      // int asset_2_amount [slot 13]
      // if asset_2_id == 0:
        load 3 // asset_2_id
        pushint 0
        ==
        bz l20_else
        // then:
          // assert(Gtxn[asset_2_txn_index].TypeEnum == Pay)
          load 11 // asset_2_txn_index
          gtxns TypeEnum
          pushint 1 // Pay
          ==
          assert
          // assert(Gtxn[asset_2_txn_index].Receiver == pool_address)
          load 11 // asset_2_txn_index
          gtxns Receiver
          load 1 // pool_address
          ==
          assert
          // asset_2_amount = Gtxn[asset_2_txn_index].Amount
          load 11 // asset_2_txn_index
          gtxns Amount
          store 13 // asset_2_amount
        b l20_end
        l20_else:
        // else:
          // assert(Gtxn[asset_2_txn_index].TypeEnum == Axfer)
          load 11 // asset_2_txn_index
          gtxns TypeEnum
          pushint 4 // Axfer
          ==
          assert
          // assert(Gtxn[asset_2_txn_index].AssetReceiver == pool_address)
          load 11 // asset_2_txn_index
          gtxns AssetReceiver
          load 1 // pool_address
          ==
          assert
          // assert(Gtxn[asset_2_txn_index].XferAsset == asset_2_id)
          load 11 // asset_2_txn_index
          gtxns XferAsset
          load 3 // asset_2_id
          ==
          assert
          // asset_2_amount = Gtxn[asset_2_txn_index].AssetAmount
          load 11 // asset_2_txn_index
          gtxns AssetAmount
          store 13 // asset_2_amount
        l20_end: // end
      // assert(Gtxn[asset_2_txn_index].Sender == user_address)
      load 11 // asset_2_txn_index
      gtxns Sender
      load 0 // user_address
      ==
      assert
      
      // int pool_tokens_out [slot 14]
      // if issued_pool_tokens:
        load 7 // issued_pool_tokens
        bz l21_else
        // then:
          // Adding liquidity after it already has some liquidity
          // bytes a_temp = itob(asset_1_amount) b* itob(issued_pool_tokens) [slot 15]
          load 12 // asset_1_amount
          itob
          load 7 // issued_pool_tokens
          itob
          b*
          store 15 // a_temp
          // bytes b_temp = itob(asset_2_amount) b* itob(issued_pool_tokens) [slot 16]
          load 13 // asset_2_amount
          itob
          load 7 // issued_pool_tokens
          itob
          b*
          store 16 // b_temp
          // int pool_tokens_output_a = btoi(a_temp b/ itob(asset_1_reserves)) [slot 17]
          load 15 // a_temp
          load 5 // asset_1_reserves
          itob
          b/
          btoi
          store 17 // pool_tokens_output_a
          // int pool_tokens_output_b = btoi(b_temp b/ itob(asset_2_reserves)) [slot 18]
          load 16 // b_temp
          load 6 // asset_2_reserves
          itob
          b/
          btoi
          store 18 // pool_tokens_output_b
          
          // if pool_tokens_output_a > pool_tokens_output_b:
            load 17 // pool_tokens_output_a
            load 18 // pool_tokens_output_b
            >
            bz l22_else
            // then:
              // Less of asset 2 supplied. Pool tokens will be issued proportionally to asset_2_amount (b)
              // Calculate amount of asset 1 to return to user as change
              // pool_tokens_out = pool_tokens_output_b
              load 18 // pool_tokens_output_b
              store 14 // pool_tokens_out
              // int expected_asset_1_amount = btoi((itob(pool_tokens_out) b* itob(asset_1_reserves)) b/ itob(issued_pool_tokens)) [slot 19]
              load 14 // pool_tokens_out
              itob
              load 5 // asset_1_reserves
              itob
              b*
              load 7 // issued_pool_tokens
              itob
              b/
              btoi
              store 19 // expected_asset_1_amount
              
              // Round Up if there is remainder
              // if btoi(b_temp b% itob(asset_2_reserves)):
                load 16 // b_temp
                load 6 // asset_2_reserves
                itob
                b%
                btoi
                bz l23_end
                // then:
                  // expected_asset_1_amount = expected_asset_1_amount + 1
                  load 19 // expected_asset_1_amount
                  pushint 1
                  +
                  store 19 // expected_asset_1_amount
                l23_end: // end
              
              // int asset_1_change = asset_1_amount - expected_asset_1_amount [slot 20]
              load 12 // asset_1_amount
              load 19 // expected_asset_1_amount
              -
              store 20 // asset_1_change
              // asset_1_amount = expected_asset_1_amount
              load 19 // expected_asset_1_amount
              store 12 // asset_1_amount
              // transfer_to_user(asset_1_id, asset_1_change)
              load 2 // asset_1_id
              load 20 // asset_1_change
              callsub main__amm__func__transfer_to_user
            b l22_end
            l22_else:
            // else:
              // Less of asset 1 supplied. Pool tokens will be issued proportionally to asset_1_amount (a)
              // Calculate amount of asset 2 to return to user as change
              // pool_tokens_out = pool_tokens_output_a
              load 17 // pool_tokens_output_a
              store 14 // pool_tokens_out
              // int expected_asset_2_amount = btoi((itob(pool_tokens_out) b* itob(asset_2_reserves)) b/ itob(issued_pool_tokens)) [slot 21]
              load 14 // pool_tokens_out
              itob
              load 6 // asset_2_reserves
              itob
              b*
              load 7 // issued_pool_tokens
              itob
              b/
              btoi
              store 21 // expected_asset_2_amount
              
              // Round Up if there is remainder
              // if btoi(a_temp b% itob(asset_1_reserves)):
                load 15 // a_temp
                load 5 // asset_1_reserves
                itob
                b%
                btoi
                bz l24_end
                // then:
                  // expected_asset_2_amount = expected_asset_2_amount + 1
                  load 21 // expected_asset_2_amount
                  pushint 1
                  +
                  store 21 // expected_asset_2_amount
                l24_end: // end
              
              // int asset_2_change = asset_2_amount - expected_asset_2_amount [slot 22]
              load 13 // asset_2_amount
              load 21 // expected_asset_2_amount
              -
              store 22 // asset_2_change
              // asset_2_amount = expected_asset_2_amount
              load 21 // expected_asset_2_amount
              store 13 // asset_2_amount
              // transfer_to_user(asset_2_id, asset_2_change)
              load 3 // asset_2_id
              load 22 // asset_2_change
              callsub main__amm__func__transfer_to_user
            l22_end: // end
          // issued_pool_tokens = issued_pool_tokens + pool_tokens_out
          load 7 // issued_pool_tokens
          load 14 // pool_tokens_out
          +
          store 7 // issued_pool_tokens
          // asset_1_reserves = asset_1_reserves + asset_1_amount
          load 5 // asset_1_reserves
          load 12 // asset_1_amount
          +
          store 5 // asset_1_reserves
          // asset_2_reserves = asset_2_reserves + asset_2_amount
          load 6 // asset_2_reserves
          load 13 // asset_2_amount
          +
          store 6 // asset_2_reserves
        b l21_end
        l21_else:
        // else:
          // Adding liquidity to the pool for the first time:
          // pool_tokens_out = sqrt(asset_1_amount * asset_2_amount) - LOCKED_POOL_TOKENS
          // issued_pool_tokens = btoi(bsqrt(itob(asset_1_amount) b* itob(asset_2_amount)))
          load 12 // asset_1_amount
          itob
          load 13 // asset_2_amount
          itob
          b*
          bsqrt
          btoi
          store 7 // issued_pool_tokens
          // assert(issued_pool_tokens >= LOCKED_POOL_TOKENS)
          load 7 // issued_pool_tokens
          pushint 1000 // LOCKED_POOL_TOKENS
          >=
          assert
          // pool_tokens_out = issued_pool_tokens - LOCKED_POOL_TOKENS
          load 7 // issued_pool_tokens
          pushint 1000 // LOCKED_POOL_TOKENS
          -
          store 14 // pool_tokens_out
          // asset_1_reserves = asset_1_amount
          load 12 // asset_1_amount
          store 5 // asset_1_reserves
          // asset_2_reserves = asset_2_amount
          load 13 // asset_2_amount
          store 6 // asset_2_reserves
        l21_end: // end
      
      // Ensure calculated amount of pool tokens is > 0
      // assert(pool_tokens_out)
      load 14 // pool_tokens_out
      assert
      // Send pool tokens to liquidity provider
      // transfer_to_user(pool_token_asset_id, pool_tokens_out)
      load 4 // pool_token_asset_id
      load 14 // pool_tokens_out
      callsub main__amm__func__transfer_to_user
      
      // State updates
      // app_local_put(1, "asset_1_reserves", asset_1_reserves)
      pushint 1
      pushbytes "asset_1_reserves"
      load 5 // asset_1_reserves
      app_local_put
      // app_local_put(1, "asset_2_reserves", asset_2_reserves)
      pushint 1
      pushbytes "asset_2_reserves"
      load 6 // asset_2_reserves
      app_local_put
      // app_local_put(1, "issued_pool_tokens", issued_pool_tokens)
      pushint 1
      pushbytes "issued_pool_tokens"
      load 7 // issued_pool_tokens
      app_local_put
      // exit(1)
      pushint 1
      return
    
    // block remove_liquidity
    main__amm__remove_liquidity:
      // Gtxn[N-1]: Transfer Pool Token to Pool from User
      // Gtxn[N]: AppCall from User
      // itxn[0]: Transfer Asset 1 to User from Pool
      // itxn[1]: Transfer Asset 2 to User from Pool
      
      // int pool_token_txn_index = Txn.GroupIndex - 1 [slot 10]
      txn GroupIndex
      pushint 1
      -
      store 10 // pool_token_txn_index
      // assert(Gtxn[pool_token_txn_index].TypeEnum == Axfer)
      load 10 // pool_token_txn_index
      gtxns TypeEnum
      pushint 4 // Axfer
      ==
      assert
      // assert(Gtxn[pool_token_txn_index].AssetReceiver == pool_address)
      load 10 // pool_token_txn_index
      gtxns AssetReceiver
      load 1 // pool_address
      ==
      assert
      // assert(Gtxn[pool_token_txn_index].XferAsset == pool_token_asset_id)
      load 10 // pool_token_txn_index
      gtxns XferAsset
      load 4 // pool_token_asset_id
      ==
      assert
      // assert(Gtxn[pool_token_txn_index].Sender == user_address)
      load 10 // pool_token_txn_index
      gtxns Sender
      load 0 // user_address
      ==
      assert
      // int removed_pool_token_amount = Gtxn[pool_token_txn_index].AssetAmount [slot 11]
      load 10 // pool_token_txn_index
      gtxns AssetAmount
      store 11 // removed_pool_token_amount
      
      // int asset_1_amount [slot 12]
      // int asset_2_amount [slot 13]
      // if (removed_pool_token_amount + LOCKED_POOL_TOKENS) == issued_pool_tokens:
        load 11 // removed_pool_token_amount
        pushint 1000 // LOCKED_POOL_TOKENS
        +
        load 7 // issued_pool_tokens
        ==
        bz l25_else
        // then:
          // asset_1_amount = asset_1_reserves
          load 5 // asset_1_reserves
          store 12 // asset_1_amount
          // asset_2_amount = asset_2_reserves
          load 6 // asset_2_reserves
          store 13 // asset_2_amount
          // removed_pool_token_amount = issued_pool_tokens
          load 7 // issued_pool_tokens
          store 11 // removed_pool_token_amount
        b l25_end
        l25_else:
        // else:
          // asset_1_amount = btoi((itob(removed_pool_token_amount) b* itob(asset_1_reserves)) b/ itob(issued_pool_tokens))
          load 11 // removed_pool_token_amount
          itob
          load 5 // asset_1_reserves
          itob
          b*
          load 7 // issued_pool_tokens
          itob
          b/
          btoi
          store 12 // asset_1_amount
          // asset_2_amount = btoi((itob(removed_pool_token_amount) b* itob(asset_2_reserves)) b/ itob(issued_pool_tokens))
          load 11 // removed_pool_token_amount
          itob
          load 6 // asset_2_reserves
          itob
          b*
          load 7 // issued_pool_tokens
          itob
          b/
          btoi
          store 13 // asset_2_amount
        l25_end: // end
      
      // assert(asset_1_amount && asset_2_amount)
      load 12 // asset_1_amount
      load 13 // asset_2_amount
      &&
      assert
      // transfer_to_user(asset_1_id, asset_1_amount)
      load 2 // asset_1_id
      load 12 // asset_1_amount
      callsub main__amm__func__transfer_to_user
      // transfer_to_user(asset_2_id, asset_2_amount)
      load 3 // asset_2_id
      load 13 // asset_2_amount
      callsub main__amm__func__transfer_to_user
      
      // State updates
      // app_local_put(1, "asset_1_reserves", asset_1_reserves - asset_1_amount)
      pushint 1
      pushbytes "asset_1_reserves"
      load 5 // asset_1_reserves
      load 12 // asset_1_amount
      -
      app_local_put
      // app_local_put(1, "asset_2_reserves", asset_2_reserves - asset_2_amount)
      pushint 1
      pushbytes "asset_2_reserves"
      load 6 // asset_2_reserves
      load 13 // asset_2_amount
      -
      app_local_put
      // app_local_put(1, "issued_pool_tokens", issued_pool_tokens - removed_pool_token_amount)
      pushint 1
      pushbytes "issued_pool_tokens"
      load 7 // issued_pool_tokens
      load 11 // removed_pool_token_amount
      -
      app_local_put
      // exit(1)
      pushint 1
      return
    
    // func transfer_to_user(asset_id: int, amount: int):
    main__amm__func__transfer_to_user:
    store 28 // amount
    store 29 // asset_id
    // return transfer(asset_id, amount, pool_address, user_address)
    load 29 // asset_id
    load 28 // amount
    load 1 // pool_address
    load 0 // user_address
    callsub __func__transfer
    retsub
    
    // func update_price_oracle():
    main__amm__func__update_price_oracle:
    // bytes asset_1_cumulative_price = app_local_get(1, "asset_1_cumulative_price") [slot 30]
    pushint 1
    pushbytes "asset_1_cumulative_price"
    app_local_get
    store 30 // asset_1_cumulative_price
    // bytes asset_2_cumulative_price = app_local_get(1, "asset_2_cumulative_price") [slot 31]
    pushint 1
    pushbytes "asset_2_cumulative_price"
    app_local_get
    store 31 // asset_2_cumulative_price
    // int time_delta = Global.LatestTimestamp - app_local_get(1, "cumulative_price_update_timestamp") [slot 32]
    global LatestTimestamp
    pushint 1
    pushbytes "cumulative_price_update_timestamp"
    app_local_get
    -
    store 32 // time_delta
    
    // if (issued_pool_tokens && time_delta):
      load 7 // issued_pool_tokens
      load 32 // time_delta
      &&
      bz l26_end
      // then:
        // asset_1_cumulative_price = asset_1_cumulative_price b+ (((itob(asset_2_reserves) b* TWO_TO_THE_64) b* itob(time_delta)) b/ itob(asset_1_reserves))
        load 30 // asset_1_cumulative_price
        load 6 // asset_2_reserves
        itob
        pushbytes "\x01\x00\x00\x00\x00\x00\x00\x00\x00" // TWO_TO_THE_64
        b*
        load 32 // time_delta
        itob
        b*
        load 5 // asset_1_reserves
        itob
        b/
        b+
        store 30 // asset_1_cumulative_price
        // asset_2_cumulative_price = asset_2_cumulative_price b+ (((itob(asset_1_reserves) b* TWO_TO_THE_64) b* itob(time_delta)) b/ itob(asset_2_reserves))
        load 31 // asset_2_cumulative_price
        load 5 // asset_1_reserves
        itob
        pushbytes "\x01\x00\x00\x00\x00\x00\x00\x00\x00" // TWO_TO_THE_64
        b*
        load 32 // time_delta
        itob
        b*
        load 6 // asset_2_reserves
        itob
        b/
        b+
        store 31 // asset_2_cumulative_price
        // app_local_put(1, "asset_1_cumulative_price", asset_1_cumulative_price)
        pushint 1
        pushbytes "asset_1_cumulative_price"
        load 30 // asset_1_cumulative_price
        app_local_put
        // app_local_put(1, "asset_2_cumulative_price", asset_2_cumulative_price)
        pushint 1
        pushbytes "asset_2_cumulative_price"
        load 31 // asset_2_cumulative_price
        app_local_put
        // app_local_put(1, "cumulative_price_update_timestamp", Global.LatestTimestamp)
        pushint 1
        pushbytes "cumulative_price_update_timestamp"
        global LatestTimestamp
        app_local_put
      l26_end: // end
    // return
    retsub

// func calculate_fixed_input_fee_amounts(input_amount: int) int, int, int:
__func__calculate_fixed_input_fee_amounts:
store 33 // input_amount
// int total_fee_share = app_local_get(1, "total_fee_share") [slot 34]
pushint 1
pushbytes "total_fee_share"
app_local_get
store 34 // total_fee_share
// int protocol_fee_ratio = app_local_get(1, "protocol_fee_ratio") [slot 35]
pushint 1
pushbytes "protocol_fee_ratio"
app_local_get
store 35 // protocol_fee_ratio

// int total_fee = (input_amount * total_fee_share) / 10000 [slot 36]
load 33 // input_amount
load 34 // total_fee_share
*
pushint 10000
/
store 36 // total_fee
// int protocol_fee = total_fee / protocol_fee_ratio [slot 37]
load 36 // total_fee
load 35 // protocol_fee_ratio
/
store 37 // protocol_fee
// int poolers_fee = total_fee - protocol_fee [slot 38]
load 36 // total_fee
load 37 // protocol_fee
-
store 38 // poolers_fee
// return total_fee, poolers_fee, protocol_fee
load 37 // protocol_fee
load 38 // poolers_fee
load 36 // total_fee
retsub

// func calculate_fixed_output_fee_amounts(swap_amount: int) int, int, int:
__func__calculate_fixed_output_fee_amounts:
store 39 // swap_amount
// int total_fee_share = app_local_get(1, "total_fee_share") [slot 40]
pushint 1
pushbytes "total_fee_share"
app_local_get
store 40 // total_fee_share
// int protocol_fee_ratio = app_local_get(1, "protocol_fee_ratio") [slot 41]
pushint 1
pushbytes "protocol_fee_ratio"
app_local_get
store 41 // protocol_fee_ratio
// int input_amount = (swap_amount * 10000) / (10000 - total_fee_share) [slot 42]
load 39 // swap_amount
pushint 10000
*
pushint 10000
load 40 // total_fee_share
-
/
store 42 // input_amount

// int total_fee = (input_amount * total_fee_share) / 10000 [slot 43]
load 42 // input_amount
load 40 // total_fee_share
*
pushint 10000
/
store 43 // total_fee
// int protocol_fee = total_fee / protocol_fee_ratio [slot 44]
load 43 // total_fee
load 41 // protocol_fee_ratio
/
store 44 // protocol_fee
// int poolers_fee = total_fee - protocol_fee [slot 45]
load 43 // total_fee
load 44 // protocol_fee
-
store 45 // poolers_fee
// return total_fee, poolers_fee, protocol_fee
load 44 // protocol_fee
load 45 // poolers_fee
load 43 // total_fee
retsub

// func calculate_fixed_input_swap(input_supply: int, output_supply: int, swap_amount: int) int:
__func__calculate_fixed_input_swap:
store 46 // swap_amount
store 47 // output_supply
store 48 // input_supply
// Calculates the output amount for a fixed-input swap ignoring fees
// k = input_supply * output_supply
// output_amount = output_supply - (k / (input_supply + swap_amount))
// bytes k = itob(input_supply) b* itob(output_supply) [slot 49]
load 48 // input_supply
itob
load 47 // output_supply
itob
b*
store 49 // k
// +1 for Round Up
// int output_amount = output_supply - (btoi((k b/ itob(input_supply + swap_amount))) + 1) [slot 50]
load 47 // output_supply
load 49 // k
load 48 // input_supply
load 46 // swap_amount
+
itob
b/
btoi
pushint 1
+
-
store 50 // output_amount
// return output_amount
load 50 // output_amount
retsub

// func calculate_fixed_output_swap(input_supply: int, output_supply: int, output_amount: int) int:
__func__calculate_fixed_output_swap:
store 51 // output_amount
store 52 // output_supply
store 53 // input_supply
// Calculates the input amount for a fixed-output swap ignoring fees
// k = input_supply * output_supply
// input_amount = (k / (output_supply - asset_output_amount)) - input_supply
// bytes k = itob(input_supply) b* itob(output_supply) [slot 54]
load 53 // input_supply
itob
load 52 // output_supply
itob
b*
store 54 // k
// +1 for Round Up
// int input_amount = (btoi((k b/ itob(output_supply - output_amount))) + 1) - input_supply [slot 55]
load 54 // k
load 52 // output_supply
load 51 // output_amount
-
itob
b/
btoi
pushint 1
+
load 53 // input_supply
-
store 55 // input_amount
// return input_amount
load 55 // input_amount
retsub

// func get_balance(account_idx: int, asset_id: int) int:
__func__get_balance:
store 56 // asset_id
store 57 // account_idx
// int balance = 0 [slot 58]
pushint 0
store 58 // balance
// if asset_id == 0:
  load 56 // asset_id
  pushint 0
  ==
  bz l27_else
  // then:
    // balance = balance(account_idx) - min_balance(account_idx)
    load 57 // account_idx
    balance
    load 57 // account_idx
    min_balance
    -
    store 58 // balance
  b l27_end
  l27_else:
  // else:
    // _, balance = asset_holding_get(AssetBalance, account_idx, asset_id)
    load 57 // account_idx
    load 56 // asset_id
    asset_holding_get AssetBalance
    pop // discarding value for _
    store 58 // balance
  l27_end: // end
// return balance
load 58 // balance
retsub

// func transfer(asset_id: int, amount: int, sender: bytes, receiver: bytes):
__func__transfer:
store 59 // receiver
store 60 // sender
store 61 // amount
store 62 // asset_id
// if asset_id == 0:
  load 62 // asset_id
  pushint 0
  ==
  bz l28_else
  // then:
    // 
    itxn_begin
    // inner_txn:
    pushint 1 // Pay
    itxn_field TypeEnum
    load 60 // sender
    itxn_field Sender
    load 59 // receiver
    itxn_field Receiver
    load 61 // amount
    itxn_field Amount
    pushint 0
    itxn_field Fee
    itxn_submit
  b l28_end
  l28_else:
  // else:
    // 
    itxn_begin
    // inner_txn:
    pushint 4 // Axfer
    itxn_field TypeEnum
    load 60 // sender
    itxn_field Sender
    load 59 // receiver
    itxn_field AssetReceiver
    load 61 // amount
    itxn_field AssetAmount
    load 62 // asset_id
    itxn_field XferAsset
    pushint 0
    itxn_field Fee
    itxn_submit
  l28_end: // end
// return
retsub

